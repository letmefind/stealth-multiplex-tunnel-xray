#!/bin/bash

# VLESS+REALITY Tunnel Installation Script
# Modern Interactive Installation with Beautiful UI

# Ensure we're running bash (not sh)
if [ -z "$BASH_VERSION" ]; then
    echo "Error: This script requires bash. Please run with: bash $0" >&2
    exit 1
fi

set -e

# Debug mode - uncomment to enable debug output
# set -x

# Modern Color Palette
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;37m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# UI Elements
BOX_TOP="â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
BOX_BOTTOM="â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
BOX_SIDE="â”‚"
ARROW="â–¶"
CHECK="âœ“"
CROSS="âœ—"
STAR="âœ¦"
DOT="â€¢"

# Function to print with modern styling
print_header() {
    echo -e "${CYAN}${BOLD}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    ðŸš€ VLESS+REALITY TUNNEL ðŸš€                â•‘"
    echo "â•‘                   Modern Installation Script                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Function to show tunnel type selection menu
show_tunnel_type_menu() {
    print_header
    print_section "Tunnel Type Selection"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Choose your tunnel type:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}Xray Tunnel${NC} ${DIM}- Stealth Multiplex Tunnel with Xray-core${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${DIM}   Supports: XHTTP, TCP, WebSocket, GRPC${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${DIM}   Features: Reality protocol, Multi-port, Multi-hop${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}Paqet Tunnel${NC} ${DIM}- High-performance packet tunnel${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${DIM}   Supports: KCP protocol, SOCKS5, Port Forwarding${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${DIM}   Features: Optimized for high traffic, MTU discovery${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}Check Xray Version${NC} ${DIM}- Check specific Xray version${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${DIM}   Check if a specific version is newer than current${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    print_section_end
}

print_section() {
    local title="$1"
    echo -e "\n${PURPLE}${BOLD}${STAR} ${title}${NC}"
    echo -e "${PURPLE}${BOX_TOP}${NC}"
}

print_section_end() {
    echo -e "${PURPLE}${BOX_BOTTOM}${NC}"
}

print_info() {
    echo -e "${BLUE}${ARROW}${NC} ${1}"
}

print_success() {
    echo -e "${GREEN}${CHECK}${NC} ${1}"
}

print_warning() {
    echo -e "${YELLOW}${DOT}${NC} ${1}"
}

print_error() {
    echo -e "${RED}${CROSS}${NC} ${1}"
}

print_input() {
    echo -e "${CYAN}${ARROW}${NC} ${1}"
}

print_config_item() {
    local key="$1"
    local value="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC} ${CYAN}${value}${NC}"
}

print_short_ids() {
    local key="$1"
    local short_ids="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}${short_ids}${NC}"
}

# Function to show animated loading
show_loading() {
    local message="$1"
    local pid=$!
    local delay=0.1
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    
    echo -ne "${BLUE}${ARROW}${NC} ${message} "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Function to get user input with modern styling
get_input() {
    local prompt="$1"
    local default="$2"
    local value
    
    if [ -n "$default" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC} ${DIM}[${default}]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "${value:-$default}"
    else
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "$value"
    fi
}

# Function to show confirmation dialog
confirm() {
    local message="$1"
    local default="${2:-n}"
    
    if [ "$default" = "y" ]; then
        echo -e "\n${GREEN}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[Y/n]${NC}"
        echo -ne "${GREEN}${ARROW}${NC} Enter choice: "
    else
        echo -e "\n${YELLOW}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[y/N]${NC}"
        echo -ne "${YELLOW}${ARROW}${NC} Enter choice: "
    fi
    
    read -r response
    if [ "$default" = "y" ]; then
        [[ "$response" =~ ^[Nn]$ ]] && return 1 || return 0
    else
        [[ "$response" =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

# Function to generate UUID
generate_uuid() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    elif command -v python3 >/dev/null 2>&1; then
        python3 -c "import uuid; print(uuid.uuid4())"
    else
        cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "12345678-1234-1234-1234-123456789abc"
    fi
}

# Handle Nginx configuration conflicts
handle_nginx_conflicts() {
    print_info "Checking for Nginx configuration conflicts..."
    
    # Create backup directory
    BACKUP_DIR="/etc/nginx/backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$BACKUP_DIR"
    
    # Check if there are any existing default server configurations
    if [ -f /etc/nginx/sites-enabled/default ]; then
        print_warning "Found existing default Nginx site"
        print_info "Creating backup in: $BACKUP_DIR"
        cp /etc/nginx/sites-enabled/default "$BACKUP_DIR/"
        
        if confirm "Do you want to disable the existing default site to avoid conflicts?"; then
            rm -f /etc/nginx/sites-enabled/default
            print_success "Default Nginx site disabled (backup created)"
        else
            print_warning "Keeping existing default site - this may cause conflicts"
        fi
    fi
    
    # Check for other conflicting configurations
    CONFLICTING_CONFIGS=$(find /etc/nginx -name "*.conf" -exec grep -l "default_server" {} \; 2>/dev/null || true)
    if [ -n "$CONFLICTING_CONFIGS" ]; then
        print_warning "Found configurations with default_server directive:"
        echo "$CONFLICTING_CONFIGS" | while read config; do
            print_info "  - $config"
            cp "$config" "$BACKUP_DIR/" 2>/dev/null || true
        done
        print_info "Backups created in: $BACKUP_DIR"
        print_info "Our configuration will override these"
    fi
}

# Restore Nginx configuration from backup
restore_nginx_backup() {
    print_info "Available Nginx backups:"
    BACKUP_DIRS=$(find /etc/nginx -name "backup-*" -type d 2>/dev/null | sort -r)
    if [ -z "$BACKUP_DIRS" ]; then
        print_warning "No Nginx backups found"
        return 1
    fi
    
    echo "$BACKUP_DIRS" | nl
    echo
    echo -e "${CYAN}${ARROW}${NC} Enter backup number to restore ${DIM}[1]${NC}: \c"
    read BACKUP_CHOICE
    BACKUP_CHOICE="${BACKUP_CHOICE:-1}"
    
    BACKUP_DIR=$(echo "$BACKUP_DIRS" | sed -n "${BACKUP_CHOICE}p")
    if [ -z "$BACKUP_DIR" ]; then
        print_error "Invalid backup selection"
        return 1
    fi
    
    print_info "Restoring from: $BACKUP_DIR"
    if [ -d "$BACKUP_DIR" ]; then
        cp "$BACKUP_DIR"/* /etc/nginx/sites-enabled/ 2>/dev/null || true
        print_success "Nginx configuration restored from backup"
        return 0
    else
        print_error "Backup directory not found"
        return 1
    fi
}

# Check Xray version
check_xray_version() {
    local UPDATE_AVAILABLE=false
    local LATEST_VERSION=""
    
    if command -v xray >/dev/null 2>&1; then
        CURRENT_VERSION=$(xray version | head -1)
        print_info "Current Xray version: ${CYAN}${CURRENT_VERSION}${NC}"
        
        # Check for latest version
        if curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest >/dev/null 2>&1; then
            LATEST_VERSION=$(curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep '"tag_name"' | head -1 | cut -d'"' -f4 | tr -d '\n\r\t' | xargs)
            if [ -n "$LATEST_VERSION" ]; then
                print_info "Latest Xray version: ${CYAN}${LATEST_VERSION}${NC}"
                # Extract version number from current version (e.g., "26.2.2" from "Xray 26.2.2")
                CURRENT_VERSION_NUM=$(echo "$CURRENT_VERSION" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
                LATEST_VERSION_NUM=$(echo "$LATEST_VERSION" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
                
                if [ -n "$CURRENT_VERSION_NUM" ] && [ -n "$LATEST_VERSION_NUM" ]; then
                    if [ "$CURRENT_VERSION_NUM" = "$LATEST_VERSION_NUM" ]; then
                        print_success "âœ… You have the latest version"
                    else
                        print_warning "âš ï¸  Update available: ${LATEST_VERSION}"
                        UPDATE_AVAILABLE=true
                    fi
                elif echo "$CURRENT_VERSION" | grep -qi "$LATEST_VERSION"; then
                    print_success "âœ… You have the latest version"
                else
                    print_warning "âš ï¸  Update available: ${LATEST_VERSION}"
                    UPDATE_AVAILABLE=true
                fi
            fi
        fi
    fi
    
    # Return status via global variable
    export XRAY_UPDATE_AVAILABLE=$UPDATE_AVAILABLE
    # Sanitize LATEST_VERSION before exporting (remove newlines and trim whitespace)
    if [ -n "$LATEST_VERSION" ]; then
        LATEST_VERSION=$(echo "$LATEST_VERSION" | tr -d '\n\r\t' | xargs)
    else
        LATEST_VERSION=""
    fi
    XRAY_LATEST_VERSION="$LATEST_VERSION"
    export XRAY_LATEST_VERSION
}

# Check specific Xray version
check_specific_xray_version() {
    local TARGET_VERSION="$1"
    
    if [ -z "$TARGET_VERSION" ]; then
        print_error "Version not specified"
        return 1
    fi
    
    # Normalize version format (add 'v' prefix if missing)
    if ! echo "$TARGET_VERSION" | grep -qE '^v[0-9]'; then
        TARGET_VERSION="v${TARGET_VERSION}"
    fi
    
    print_section "Checking Xray Version"
    
    # Check if Xray is installed
    if ! command -v xray >/dev/null 2>&1; then
        print_error "Xray is not installed"
        print_info "Target version: ${CYAN}${TARGET_VERSION}${NC}"
        print_section_end
        return 1
    fi
    
    CURRENT_VERSION=$(xray version | head -1)
    print_info "Current Xray version: ${CYAN}${CURRENT_VERSION}${NC}"
    print_info "Checking version: ${CYAN}${TARGET_VERSION}${NC}"
    
    # Check if target version exists on GitHub
    print_info "Checking if version ${CYAN}${TARGET_VERSION}${NC} exists..."
    if curl -s --connect-timeout 5 "https://api.github.com/repos/XTLS/Xray-core/releases/tags/${TARGET_VERSION}" >/dev/null 2>&1; then
        print_success "Version ${CYAN}${TARGET_VERSION}${NC} exists on GitHub"
        
        # Extract version numbers for comparison
        CURRENT_VERSION_NUM=$(echo "$CURRENT_VERSION" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        TARGET_VERSION_NUM=$(echo "$TARGET_VERSION" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        
        if [ -n "$CURRENT_VERSION_NUM" ] && [ -n "$TARGET_VERSION_NUM" ]; then
            # Compare versions
            if [ "$CURRENT_VERSION_NUM" = "$TARGET_VERSION_NUM" ]; then
                print_success "âœ… You already have version ${CYAN}${TARGET_VERSION}${NC}"
            else
                # Simple version comparison (major.minor.patch)
                CURRENT_MAJOR=$(echo "$CURRENT_VERSION_NUM" | cut -d. -f1)
                CURRENT_MINOR=$(echo "$CURRENT_VERSION_NUM" | cut -d. -f2)
                CURRENT_PATCH=$(echo "$CURRENT_VERSION_NUM" | cut -d. -f3)
                
                TARGET_MAJOR=$(echo "$TARGET_VERSION_NUM" | cut -d. -f1)
                TARGET_MINOR=$(echo "$TARGET_VERSION_NUM" | cut -d. -f2)
                TARGET_PATCH=$(echo "$TARGET_VERSION_NUM" | cut -d. -f3)
                
                IS_NEWER=false
                if [ "$TARGET_MAJOR" -gt "$CURRENT_MAJOR" ]; then
                    IS_NEWER=true
                elif [ "$TARGET_MAJOR" -eq "$CURRENT_MAJOR" ] && [ "$TARGET_MINOR" -gt "$CURRENT_MINOR" ]; then
                    IS_NEWER=true
                elif [ "$TARGET_MAJOR" -eq "$CURRENT_MAJOR" ] && [ "$TARGET_MINOR" -eq "$CURRENT_MINOR" ] && [ "$TARGET_PATCH" -gt "$CURRENT_PATCH" ]; then
                    IS_NEWER=true
                fi
                
                if [ "$IS_NEWER" = true ]; then
                    print_warning "âš ï¸  Version ${CYAN}${TARGET_VERSION}${NC} is NEWER than your current version"
                    echo
                    if confirm "Do you want to update to ${TARGET_VERSION}?"; then
                        if update_xray "$TARGET_VERSION"; then
                            print_success "Xray updated successfully to ${CYAN}${TARGET_VERSION}${NC}"
                        else
                            print_error "Failed to update Xray"
                        fi
                    fi
                else
                    print_warning "âš ï¸  Version ${CYAN}${TARGET_VERSION}${NC} is OLDER than your current version"
                    echo
                    if confirm "Do you still want to downgrade to ${TARGET_VERSION}?"; then
                        if update_xray "$TARGET_VERSION"; then
                            print_success "Xray downgraded successfully to ${CYAN}${TARGET_VERSION}${NC}"
                        else
                            print_error "Failed to downgrade Xray"
                        fi
                    fi
                fi
            fi
        else
            print_warning "Could not compare versions, but ${CYAN}${TARGET_VERSION}${NC} exists"
            echo
            if confirm "Do you want to update to ${TARGET_VERSION}?"; then
                if update_xray "$TARGET_VERSION"; then
                    print_success "Xray updated successfully to ${CYAN}${TARGET_VERSION}${NC}"
                else
                    print_error "Failed to update Xray"
                fi
            fi
        fi
    else
        print_error "Version ${CYAN}${TARGET_VERSION}${NC} not found on GitHub"
        print_info "Please check the version tag format (e.g., v1.8.4 or 1.8.4)"
        print_section_end
        return 1
    fi
    
    print_section_end
    return 0
}

# Update Xray to latest version
update_xray() {
    local TARGET_VERSION="$1"
    
    if [ -z "$TARGET_VERSION" ]; then
        print_error "Target version not specified"
        return 1
    fi
    
    print_section "Updating Xray"
    print_info "Updating Xray to ${CYAN}${TARGET_VERSION}${NC}..."
    
    # Detect architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="64" ;;
        aarch64|arm64) ARCH="arm64-v8a" ;;
        armv7l) ARCH="arm32-v7a" ;;
        *) print_error "Unsupported architecture: $ARCH"; return 1 ;;
    esac
    
    # Create temporary directory
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # Download URLs (multiple mirrors)
    DOWNLOAD_URLS=(
        "https://github.com/XTLS/Xray-core/releases/download/${TARGET_VERSION}/Xray-linux-${ARCH}.zip"
        "https://ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${TARGET_VERSION}/Xray-linux-${ARCH}.zip"
        "https://mirror.ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${TARGET_VERSION}/Xray-linux-${ARCH}.zip"
        "https://download.fastgit.org/XTLS/Xray-core/releases/download/${TARGET_VERSION}/Xray-linux-${ARCH}.zip"
    )
    
    # Try downloading from multiple mirrors
    DOWNLOAD_SUCCESS=false
    for url in "${DOWNLOAD_URLS[@]}"; do
        print_info "Trying to download from: $url"
        if wget -q --timeout=15 "$url" -O xray.zip || curl -L --connect-timeout 15 "$url" -o xray.zip; then
            print_success "Downloaded Xray binary successfully"
            DOWNLOAD_SUCCESS=true
            break
        else
            print_warning "Failed to download from: $url"
        fi
    done
    
    if [ "$DOWNLOAD_SUCCESS" = false ]; then
        print_error "Failed to download Xray binary from all mirrors"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Extract archive
    if command -v unzip >/dev/null 2>&1; then
        unzip -q xray.zip
    else
        print_error "unzip command not found. Please install unzip first."
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Stop Xray services if running
    if systemctl is-active --quiet xray-a 2>/dev/null; then
        print_info "Stopping xray-a service..."
        systemctl stop xray-a
    fi
    if systemctl is-active --quiet xray-b 2>/dev/null; then
        print_info "Stopping xray-b service..."
        systemctl stop xray-b
    fi
    if systemctl is-active --quiet xray-c 2>/dev/null; then
        print_info "Stopping xray-c service..."
        systemctl stop xray-c
    fi
    
    # Backup old binary
    if [ -f /usr/local/bin/xray ]; then
        print_info "Backing up old Xray binary..."
        cp /usr/local/bin/xray /usr/local/bin/xray.backup.$(date +%Y%m%d_%H%M%S)
    fi
    
    # Install new binary
    print_info "Installing new Xray binary..."
    if [ -f xray ]; then
        cp xray /usr/local/bin/xray
        chmod +x /usr/local/bin/xray
        chown root:root /usr/local/bin/xray
        print_success "Xray updated successfully"
    else
        print_error "Xray binary not found in archive"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Verify installation
    if /usr/local/bin/xray version >/dev/null 2>&1; then
        NEW_VERSION=$(/usr/local/bin/xray version | head -1)
        print_success "New Xray version: ${CYAN}${NEW_VERSION}${NC}"
    else
        print_error "Failed to verify new Xray installation"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Cleanup
    cd /
    rm -rf "$TEMP_DIR"
    
    print_success "Xray update completed successfully"
    print_section_end
    return 0
}

# Install Xray offline
install_xray_offline() {
    print_info "Checking Xray installation options..."
    
    # Get latest version information
    LATEST_VERSION=""
    if curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest >/dev/null 2>&1; then
        LATEST_VERSION=$(curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
        if [ -n "$LATEST_VERSION" ]; then
            print_info "Latest Xray version available: ${CYAN}${LATEST_VERSION}${NC}"
        fi
    fi
    
    # Check if we have internet connectivity
    if curl -s --connect-timeout 5 https://github.com >/dev/null 2>&1; then
        print_info "Internet connection available"
        print_info "Installation methods:"
        print_info "  ${GREEN}1. Online Installation${NC} - Uses official Xray installer (recommended)"
        print_info "  ${YELLOW}2. Offline Installation${NC} - Downloads binary directly (for restricted networks)"
        
        if confirm "Do you want to try online installation first?"; then
            print_info "Attempting online installation..."
            if bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install; then
                print_success "Xray installed successfully via online method"
                if [ -n "$LATEST_VERSION" ]; then
                    print_info "Installed version: ${CYAN}$(xray version | head -1)${NC}"
                fi
                return 0
            else
                print_warning "Online installation failed, trying offline method..."
            fi
        else
            print_info "Skipping online installation, using offline method..."
        fi
    else
        print_warning "No internet connection detected, using offline method..."
    fi
    
    # Offline installation method
    print_info "Installing Xray offline..."
    
    # Detect system architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="64" ;;
        aarch64|arm64) ARCH="arm64-v8a" ;;
        armv7l) ARCH="arm32-v7a" ;;
        *) print_error "Unsupported architecture: $ARCH"; return 1 ;;
    esac
    print_info "Detected architecture: ${CYAN}${ARCH}${NC}"
    
    # Use latest version if available, otherwise fallback to stable
    if [ -n "$LATEST_VERSION" ]; then
        XRAY_VERSION="$LATEST_VERSION"
        print_info "Using latest version: ${CYAN}${XRAY_VERSION}${NC}"
    else
        XRAY_VERSION="v1.8.18"
        print_warning "Using fallback version: ${CYAN}${XRAY_VERSION}${NC}"
    fi
    
    # Create temporary directory
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # Download Xray binary (try multiple mirrors)
    DOWNLOAD_URLS=(
        "https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://mirror.ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://download.fastgit.org/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
    )
    
    for url in "${DOWNLOAD_URLS[@]}"; do
        print_info "Trying to download from: $url"
        if wget -q --timeout=10 "$url" -O xray.zip || curl -L --connect-timeout 10 "$url" -o xray.zip; then
            print_success "Downloaded Xray binary successfully"
            break
        else
            print_warning "Failed to download from: $url"
        fi
    done
    
    if [ ! -f "xray.zip" ]; then
        print_error "Failed to download Xray binary from all mirrors"
        print_info "Please download Xray manually:"
        print_info "1. Go to: https://github.com/XTLS/Xray-core/releases"
        print_info "2. Download Xray-linux-${ARCH}.zip"
        print_info "3. Extract and place xray binary in /usr/local/bin/"
        print_info "4. Run: chmod +x /usr/local/bin/xray"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Extract and install
    if command -v unzip >/dev/null 2>&1; then
        unzip -q xray.zip
    else
        print_error "unzip command not found. Please install unzip first."
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Install binary
    if [ -f "xray" ]; then
        cp xray /usr/local/bin/
        chmod +x /usr/local/bin/xray
        
        # Create systemd service
        cat > /etc/systemd/system/xray.service << 'EOF'
[Unit]
Description=Xray Service
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/config.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
        
        # Create directories
        mkdir -p /etc/xray /var/log/xray
        chown nobody:nogroup /var/log/xray
        
        # Enable service
        systemctl daemon-reload
        systemctl enable xray
        
        print_success "Xray installed successfully via offline method"
        INSTALLED_VERSION=$(/usr/local/bin/xray version | head -1)
        print_info "Installed version: ${CYAN}${INSTALLED_VERSION}${NC}"
        if [ -n "$LATEST_VERSION" ] && [ "$XRAY_VERSION" = "$LATEST_VERSION" ]; then
            print_success "âœ… Latest version installed successfully"
        fi
        
        cd /
        rm -rf "$TEMP_DIR"
        return 0
    else
        print_error "Xray binary not found in downloaded archive"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
}

# Function to generate Reality keys
generate_reality_keys() {
    if ! command -v xray >/dev/null 2>&1; then
        print_error "Xray not found. Cannot generate Reality keys."
        print_error "Please install Xray first or run the installer with Xray already installed."
        exit 1
    fi
    
    # Generate keys using xray - always generate new keys
    KEYS=$(xray x25519 2>&1)
    
    # Parse keys - xray outputs: "Private key: ..." and "Public key: ..."
    # Method 1: Try exact format match
    PRIVATE_KEY=$(echo "$KEYS" | grep -i "Private key:" | sed 's/.*Private key:[[:space:]]*//' | sed 's/[[:space:]]*$//' | head -1)
    PUBLIC_KEY=$(echo "$KEYS" | grep -i "Public key:" | sed 's/.*Public key:[[:space:]]*//' | sed 's/[[:space:]]*$//' | head -1)
    
    # Method 2: If Method 1 failed, try awk with different field numbers
    if [ -z "$PRIVATE_KEY" ] || [ -z "$PUBLIC_KEY" ]; then
        PRIVATE_KEY=$(echo "$KEYS" | grep -i "Private" | awk '{for(i=3;i<=NF;i++) printf "%s", $i (i<NF?" ":""); print ""}' | head -1 | xargs)
        PUBLIC_KEY=$(echo "$KEYS" | grep -i "Public" | awk '{for(i=3;i<=NF;i++) printf "%s", $i (i<NF?" ":""); print ""}' | head -1 | xargs)
    fi
    
    # Method 3: Extract base64-like strings (supports base64url format with - and _)
    if [ -z "$PRIVATE_KEY" ] || [ -z "$PUBLIC_KEY" ]; then
        # Extract all base64/base64url strings (43-44 chars, may contain - and _)
        ALL_KEYS=($(echo "$KEYS" | grep -oE '[A-Za-z0-9+/_-]{43}={0,1}' | grep -v '^$'))
        if [ ${#ALL_KEYS[@]} -ge 2 ]; then
            # First key is usually private, second is public
            PRIVATE_KEY="${ALL_KEYS[0]}"
            PUBLIC_KEY="${ALL_KEYS[1]}"
        fi
    fi
    
    # Validate keys format and ensure they are different
    if [ -z "$PUBLIC_KEY" ] || [ -z "$PRIVATE_KEY" ] || [ ${#PUBLIC_KEY} -lt 40 ] || [ ${#PRIVATE_KEY} -lt 40 ]; then
        print_error "Failed to parse Reality keys from xray output."
        print_error "xray x25519 output was:"
        echo "$KEYS"
        print_error "Please ensure xray is properly installed and working."
        exit 1
    fi
    
    # Ensure keys are different (they should never be the same)
    if [ "$PUBLIC_KEY" = "$PRIVATE_KEY" ]; then
        print_error "Error: Public key and Private key are identical. This should never happen."
        print_error "xray x25519 output was:"
        echo "$KEYS"
        print_error "Please try running the installer again."
        exit 1
    fi
    
    # Generate single short ID (always new)
    SHORT_ID=$(openssl rand -hex 8 2>/dev/null || head -c 8 /dev/urandom | xxd -p 2>/dev/null || echo $(date +%s | sha256sum | cut -c1-16))
    SHORT_IDS="\"$SHORT_ID\""
    
    print_success "Generated new Reality keys successfully"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short ID:${NC} ${CYAN}${SHORT_ID}${NC}"
    
    # Generate seed for post-quantum cryptography (only for TCP + Reality)
    # Seed will be generated later when transport protocol is known
    SEED=""
    export SEED
    
    # Export the variables so they're available globally
    export PUBLIC_KEY
    export PRIVATE_KEY
    export SHORT_ID
    export SHORT_IDS
}

# Function to validate port
validate_port() {
    local port="$1"
    # Check if port is a number
    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    # Check if port is in valid range (1-65535)
    if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        return 1
    fi
    # Reject system ports (1-10) as they are reserved
    if [ "$port" -ge 1 ] && [ "$port" -le 10 ]; then
        return 1
    fi
    return 0
}

# Function to validate IP
validate_ip() {
    local ip="$1"
    # More comprehensive IP validation
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Check each octet is between 0-255
        IFS='.' read -ra ADDR <<< "$ip"
        for i in "${ADDR[@]}"; do
            if [[ $i -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# Function to show server selection menu
show_server_menu() {
    print_section "Server Type Selection"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Choose your server type:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}Server A (Tunnel Server)${NC} ${DIM}- Receives traffic and forwards to Server B${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}Server B (Destination Server)${NC} ${DIM}- Receives tunneled traffic and routes to services${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}Auto-detect${NC} ${DIM}- Automatically detect server type${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    print_section_end
}

# Function to detect server type
detect_server_type() {
    print_info "Auto-detecting server type..." >&2
    
    if command -v nginx >/dev/null 2>&1; then
        echo "b"
    else
        echo "a"
    fi
}

# Function to find optimal MTU for tunnel
find_optimal_mtu() {
    local target_host="${1:-8.8.8.8}"
    local start_mtu="${2:-1500}"
    local min_mtu="${3:-1280}"
    local optimal_mtu=1350  # Default for tunnel
    
    print_info "Finding optimal MTU (testing against $target_host)..."
    print_info "This may take a moment..."
    
    # Check if ping is available
    if ! command -v ping >/dev/null 2>&1; then
        print_warning "ping command not found, using default MTU: $optimal_mtu"
        echo "$optimal_mtu"
        return 0
    fi
    
    # Test MTU values from start_mtu down to min_mtu
    local test_mtu=$start_mtu
    local found_optimal=false
    
    # For tunnel, we typically want MTU around 1350-1400
    # So we'll test common tunnel MTU values first
    local tunnel_mtus=(1500 1450 1400 1350 1300 1280)
    
    for mtu in "${tunnel_mtus[@]}"; do
        # Calculate packet size (MTU - IP header - ICMP header = MTU - 28)
        local packet_size=$((mtu - 28))
        
        if [ $packet_size -lt 0 ]; then
            continue
        fi
        
        # Test with ping (don't fragment flag)
        if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
            optimal_mtu=$mtu
            found_optimal=true
            print_success "Found working MTU: $optimal_mtu"
            break
        fi
    done
    
    # If no optimal found in tunnel range, try binary search
    if [ "$found_optimal" = false ]; then
        print_info "Testing MTU range..."
        local low=$min_mtu
        local high=$start_mtu
        local best_mtu=$min_mtu
        
        while [ $low -le $high ]; do
            local mid=$(( (low + high) / 2 ))
            local packet_size=$((mid - 28))
            
            if [ $packet_size -lt 0 ]; then
                low=$((mid + 1))
                continue
            fi
            
            if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
                best_mtu=$mid
                optimal_mtu=$mid
                low=$((mid + 1))
            else
                high=$((mid - 1))
            fi
        done
        
        if [ $best_mtu -gt $min_mtu ]; then
            optimal_mtu=$best_mtu
            print_success "Found optimal MTU: $optimal_mtu"
        else
            print_warning "Could not determine optimal MTU, using default: $optimal_mtu"
        fi
    fi
    
    echo "$optimal_mtu"
}

# Function to configure BBR and TCP optimizations
configure_bbr_and_tcp() {
    print_info "Configuring BBR and TCP buffer optimizations..."
    
    # Check if BBR is already enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR is already enabled"
        else
            print_info "Enabling BBR..."
        fi
    fi
    
    # Function to check if sysctl parameter exists
    check_sysctl_exists() {
        local param="$1"
        [ -f "/proc/sys/${param//\./\/}" ] 2>/dev/null
    }
    
    # Create comprehensive sysctl configuration
    cat > /etc/sysctl.d/99-xray-optimization.conf << 'EOF'
# BBR Congestion Control
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr

# TCP Buffer Optimizations for High Bandwidth
net.core.rmem_max=134217728
net.core.wmem_max=134217728
net.ipv4.tcp_rmem=4096 87380 67108864
net.ipv4.tcp_wmem=4096 65536 67108864
net.ipv4.tcp_mem=262144 524288 1048576

# TCP Window Scaling
net.ipv4.tcp_window_scaling=1
net.ipv4.tcp_timestamps=1
net.ipv4.tcp_sack=1

# TCP Fast Open
net.ipv4.tcp_fastopen=3

# Socket Options
net.core.somaxconn=65535
net.core.netdev_max_backlog=5000

# TCP Keepalive
net.ipv4.tcp_keepalive_time=600
net.ipv4.tcp_keepalive_probes=3
net.ipv4.tcp_keepalive_intvl=15

# TCP SYN Cookies (DDoS protection)
net.ipv4.tcp_syncookies=1

# TCP Fin Timeout
net.ipv4.tcp_fin_timeout=30

# TCP Tw Reuse
net.ipv4.tcp_tw_reuse=1

# MTU Settings for Packet Tunnel
# Default MTU for packet tunnel: 1350 (optimal for VPN/tunnel connections)
# This prevents packet fragmentation and improves performance
net.ipv4.ip_no_pmtu_disc=0
net.ipv4.tcp_mtu_probing=1
net.ipv4.tcp_base_mss=1024

# IP Forwarding (if needed)
# net.ipv4.ip_forward=1
EOF
    
    # Add optional connection tracking settings if available
    if check_sysctl_exists "net.netfilter.nf_conntrack_max"; then
        cat >> /etc/sysctl.d/99-xray-optimization.conf << 'EOF'

# Connection Tracking (only if nf_conntrack module is loaded)
net.netfilter.nf_conntrack_max=1000000
EOF
        if check_sysctl_exists "net.ipv4.netfilter.ip_conntrack_max"; then
            echo "net.ipv4.netfilter.ip_conntrack_max=1000000" >> /etc/sysctl.d/99-xray-optimization.conf
        fi
    fi
    
    # Apply sysctl settings (ignore errors for missing parameters)
    sysctl --system >/dev/null 2>&1 || true
    
    # Verify BBR is enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR enabled successfully"
        else
            print_warning "BBR may require kernel module. Current: $CURRENT_CC"
            print_info "To enable BBR manually, run: modprobe tcp_bbr"
        fi
    fi
    
    print_success "TCP buffer optimizations configured"
    print_info "Optimizations applied:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}BBR:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}TCP Buffers:${NC} Optimized for high bandwidth"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Window Scaling:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Fast Open:${NC} Enabled"
    
    # Create find_optimal_mtu.sh script in /root for compatibility with other scripts
    print_info "Creating find_optimal_mtu.sh script..."
    cat > /root/find_optimal_mtu.sh << 'MTU_SCRIPT_EOF'
#!/bin/bash

# Find Optimal MTU Script
# This script finds the optimal MTU for tunnel connections
# Embedded in main install script - no need to download separately

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to find optimal MTU for tunnel
find_optimal_mtu() {
    local target_host="${1:-8.8.8.8}"
    local start_mtu="${2:-1500}"
    local min_mtu="${3:-1280}"
    local optimal_mtu=1350  # Default for tunnel
    
    log_info "Finding optimal MTU (testing against $target_host)..."
    log_info "This may take a moment..."
    
    # Check if ping is available
    if ! command -v ping >/dev/null 2>&1; then
        log_warning "ping command not found, using default MTU: $optimal_mtu"
        echo "$optimal_mtu"
        return 0
    fi
    
    # Test MTU values from start_mtu down to min_mtu
    local test_mtu=$start_mtu
    local found_optimal=false
    
    # For tunnel, we typically want MTU around 1350-1400
    # So we'll test common tunnel MTU values first
    local tunnel_mtus=(1500 1450 1400 1350 1300 1280)
    
    for mtu in "${tunnel_mtus[@]}"; do
        # Calculate packet size (MTU - IP header - ICMP header = MTU - 28)
        local packet_size=$((mtu - 28))
        
        if [ $packet_size -lt 0 ]; then
            continue
        fi
        
        # Test with ping (don't fragment flag)
        if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
            optimal_mtu=$mtu
            found_optimal=true
            log_success "Found working MTU: $optimal_mtu"
            break
        fi
    done
    
    # If no optimal found in tunnel range, try binary search
    if [ "$found_optimal" = false ]; then
        log_info "Testing MTU range..."
        local low=$min_mtu
        local high=$start_mtu
        local best_mtu=$min_mtu
        
        while [ $low -le $high ]; do
            local mid=$(( (low + high) / 2 ))
            local packet_size=$((mid - 28))
            
            if [ $packet_size -lt 0 ]; then
                low=$((mid + 1))
                continue
            fi
            
            if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
                best_mtu=$mid
                optimal_mtu=$mid
                low=$((mid + 1))
            else
                high=$((mid - 1))
            fi
        done
        
        if [ $best_mtu -gt $min_mtu ]; then
            optimal_mtu=$best_mtu
            log_success "Found optimal MTU: $optimal_mtu"
        else
            log_warning "Could not determine optimal MTU, using default: $optimal_mtu"
        fi
    fi
    
    echo "$optimal_mtu"
}

# Main execution (if run directly, not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Script is being executed directly
    OPTIMAL_MTU=$(find_optimal_mtu "$@")
    echo "$OPTIMAL_MTU"
fi
MTU_SCRIPT_EOF
    
    chmod +x /root/find_optimal_mtu.sh
    print_success "Created /root/find_optimal_mtu.sh"
    
    # Optional: Find and display optimal MTU
    if confirm "Do you want to find optimal MTU for your tunnel connection?"; then
        OPTIMAL_MTU=$(find_optimal_mtu)
        print_success "Optimal MTU: ${CYAN}${OPTIMAL_MTU}${NC}"
        print_info "You can use this MTU value in your tunnel configuration"
        print_info "For Xray TUN interface, set: ${CYAN}\"MTU\": ${OPTIMAL_MTU}${NC}"
    fi
}

# Function to find optimal MTU for tunnel
find_optimal_mtu() {
    local target_host="${1:-8.8.8.8}"
    local start_mtu="${2:-1500}"
    local min_mtu="${3:-1280}"
    local optimal_mtu=1350  # Default for tunnel
    
    print_info "Finding optimal MTU (testing against $target_host)..."
    print_info "This may take a moment..."
    
    # Check if ping is available
    if ! command -v ping >/dev/null 2>&1; then
        print_warning "ping command not found, using default MTU: $optimal_mtu"
        echo "$optimal_mtu"
        return 0
    fi
    
    # Test MTU values from start_mtu down to min_mtu
    local test_mtu=$start_mtu
    local found_optimal=false
    
    # For tunnel, we typically want MTU around 1350-1400
    # So we'll test common tunnel MTU values first
    local tunnel_mtus=(1500 1450 1400 1350 1300 1280)
    
    for mtu in "${tunnel_mtus[@]}"; do
        # Calculate packet size (MTU - IP header - ICMP header = MTU - 28)
        local packet_size=$((mtu - 28))
        
        if [ $packet_size -lt 0 ]; then
            continue
        fi
        
        # Test with ping (don't fragment flag)
        if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
            optimal_mtu=$mtu
            found_optimal=true
            print_success "Found working MTU: $optimal_mtu"
            break
        fi
    done
    
    # If no optimal found in tunnel range, try binary search
    if [ "$found_optimal" = false ]; then
        print_info "Testing MTU range..."
        local low=$min_mtu
        local high=$start_mtu
        local best_mtu=$min_mtu
        
        while [ $low -le $high ]; do
            local mid=$(( (low + high) / 2 ))
            local packet_size=$((mid - 28))
            
            if [ $packet_size -lt 0 ]; then
                low=$((mid + 1))
                continue
            fi
            
            if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
                best_mtu=$mid
                optimal_mtu=$mid
                low=$((mid + 1))
            else
                high=$((mid - 1))
            fi
        done
        
        if [ $best_mtu -gt $min_mtu ]; then
            optimal_mtu=$best_mtu
            print_success "Found optimal MTU: $optimal_mtu"
        else
            print_warning "Could not determine optimal MTU, using default: $optimal_mtu"
        fi
    fi
    
    echo "$optimal_mtu"
}

# Function to configure BBR and TCP optimizations
configure_bbr_and_tcp() {
    print_info "Configuring BBR and TCP buffer optimizations..."
    
    # Check if BBR is already enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR is already enabled"
        else
            print_info "Enabling BBR..."
        fi
    fi
    
    # Function to check if sysctl parameter exists
    check_sysctl_exists() {
        local param="$1"
        [ -f "/proc/sys/${param//\./\/}" ] 2>/dev/null
    }
    
    # Create comprehensive sysctl configuration
    cat > /etc/sysctl.d/99-xray-optimization.conf << 'EOF'
# BBR Congestion Control
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr

# TCP Buffer Optimizations for High Bandwidth
net.core.rmem_max=134217728
net.core.wmem_max=134217728
net.ipv4.tcp_rmem=4096 87380 67108864
net.ipv4.tcp_wmem=4096 65536 67108864
net.ipv4.tcp_mem=262144 524288 1048576

# TCP Window Scaling
net.ipv4.tcp_window_scaling=1
net.ipv4.tcp_timestamps=1
net.ipv4.tcp_sack=1

# TCP Fast Open
net.ipv4.tcp_fastopen=3

# Socket Options
net.core.somaxconn=65535
net.core.netdev_max_backlog=5000

# TCP Keepalive
net.ipv4.tcp_keepalive_time=600
net.ipv4.tcp_keepalive_probes=3
net.ipv4.tcp_keepalive_intvl=15

# TCP SYN Cookies (DDoS protection)
net.ipv4.tcp_syncookies=1

# TCP Fin Timeout
net.ipv4.tcp_fin_timeout=30

# TCP Tw Reuse
net.ipv4.tcp_tw_reuse=1

# MTU Settings for Packet Tunnel
# Default MTU for packet tunnel: 1350 (optimal for VPN/tunnel connections)
# This prevents packet fragmentation and improves performance
net.ipv4.ip_no_pmtu_disc=0
net.ipv4.tcp_mtu_probing=1
net.ipv4.tcp_base_mss=1024

# IP Forwarding (if needed)
# net.ipv4.ip_forward=1
EOF
    
    # Add optional connection tracking settings if available
    if check_sysctl_exists "net.netfilter.nf_conntrack_max"; then
        cat >> /etc/sysctl.d/99-xray-optimization.conf << 'EOF'

# Connection Tracking (only if nf_conntrack module is loaded)
net.netfilter.nf_conntrack_max=1000000
EOF
        if check_sysctl_exists "net.ipv4.netfilter.ip_conntrack_max"; then
            echo "net.ipv4.netfilter.ip_conntrack_max=1000000" >> /etc/sysctl.d/99-xray-optimization.conf
        fi
    fi
    
    # Apply sysctl settings (ignore errors for missing parameters)
    sysctl --system >/dev/null 2>&1 || true
    
    # Verify BBR is enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR enabled successfully"
        else
            print_warning "BBR may require kernel module. Current: $CURRENT_CC"
            print_info "To enable BBR manually, run: modprobe tcp_bbr"
        fi
    fi
    
    print_success "TCP buffer optimizations configured"
    print_info "Optimizations applied:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}BBR:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}TCP Buffers:${NC} Optimized for high bandwidth"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Window Scaling:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Fast Open:${NC} Enabled"
    
    # Create find_optimal_mtu.sh script in /root for compatibility with other scripts
    print_info "Creating find_optimal_mtu.sh script..."
    cat > /root/find_optimal_mtu.sh << 'MTU_SCRIPT_EOF'
#!/bin/bash

# Find Optimal MTU Script
# This script finds the optimal MTU for tunnel connections
# Embedded in main install script - no need to download separately

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to find optimal MTU for tunnel
find_optimal_mtu() {
    local target_host="${1:-8.8.8.8}"
    local start_mtu="${2:-1500}"
    local min_mtu="${3:-1280}"
    local optimal_mtu=1350  # Default for tunnel
    
    log_info "Finding optimal MTU (testing against $target_host)..."
    log_info "This may take a moment..."
    
    # Check if ping is available
    if ! command -v ping >/dev/null 2>&1; then
        log_warning "ping command not found, using default MTU: $optimal_mtu"
        echo "$optimal_mtu"
        return 0
    fi
    
    # Test MTU values from start_mtu down to min_mtu
    local test_mtu=$start_mtu
    local found_optimal=false
    
    # For tunnel, we typically want MTU around 1350-1400
    # So we'll test common tunnel MTU values first
    local tunnel_mtus=(1500 1450 1400 1350 1300 1280)
    
    for mtu in "${tunnel_mtus[@]}"; do
        # Calculate packet size (MTU - IP header - ICMP header = MTU - 28)
        local packet_size=$((mtu - 28))
        
        if [ $packet_size -lt 0 ]; then
            continue
        fi
        
        # Test with ping (don't fragment flag)
        if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
            optimal_mtu=$mtu
            found_optimal=true
            log_success "Found working MTU: $optimal_mtu"
            break
        fi
    done
    
    # If no optimal found in tunnel range, try binary search
    if [ "$found_optimal" = false ]; then
        log_info "Testing MTU range..."
        local low=$min_mtu
        local high=$start_mtu
        local best_mtu=$min_mtu
        
        while [ $low -le $high ]; do
            local mid=$(( (low + high) / 2 ))
            local packet_size=$((mid - 28))
            
            if [ $packet_size -lt 0 ]; then
                low=$((mid + 1))
                continue
            fi
            
            if ping -c 1 -M do -s $packet_size -W 2 "$target_host" >/dev/null 2>&1; then
                best_mtu=$mid
                optimal_mtu=$mid
                low=$((mid + 1))
            else
                high=$((mid - 1))
            fi
        done
        
        if [ $best_mtu -gt $min_mtu ]; then
            optimal_mtu=$best_mtu
            log_success "Found optimal MTU: $optimal_mtu"
        else
            log_warning "Could not determine optimal MTU, using default: $optimal_mtu"
        fi
    fi
    
    echo "$optimal_mtu"
}

# Main execution (if run directly, not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Script is being executed directly
    OPTIMAL_MTU=$(find_optimal_mtu "$@")
    echo "$OPTIMAL_MTU"
fi
MTU_SCRIPT_EOF
    
    chmod +x /root/find_optimal_mtu.sh
    print_success "Created /root/find_optimal_mtu.sh"
    
    # Optional: Find and display optimal MTU
    if confirm "Do you want to find optimal MTU for your tunnel connection?"; then
        OPTIMAL_MTU=$(find_optimal_mtu)
        print_success "Optimal MTU: ${CYAN}${OPTIMAL_MTU}${NC}"
        print_info "You can use this MTU value in your tunnel configuration"
        print_info "For Xray TUN interface, set: ${CYAN}\"MTU\": ${OPTIMAL_MTU}${NC}"
    fi
}

# Function to install Server A
install_server_a() {
    print_section "Server A Configuration"
    
    # Get configuration from user
    print_info "I will ask you for each configuration detail one by one."
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: Server B IP or Domain (Domain for WebSocket, IP for others)
    # Note: We'll ask for transport protocol first, then ask appropriate question
    # For now, we'll ask for IP, but if WebSocket is selected, we'll update it to domain
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the IP address of Server B (destination server)?"
    echo -e "${DIM}This is the server where your tunneled traffic will be sent.${NC}"
    echo -e "${DIM}Note: For WebSocket, you'll be asked for domain name later.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
    read SERVER_B_IP
    
    while [ -z "$SERVER_B_IP" ] || ! validate_ip "$SERVER_B_IP"; do
        if [ -z "$SERVER_B_IP" ]; then
            print_error "Server B IP address is required. Please enter a valid IP address."
        else
            print_error "Invalid IP address format. Please enter a valid IP like 192.168.1.100"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
        read SERVER_B_IP
    done
    print_success "Server B IP: ${CYAN}${SERVER_B_IP}${NC}"
    
    # Question 2: Tunnel Port
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What port should be used for the VLESS tunnel connection?"
    echo -e "${DIM}This is the port that Server A will connect to on Server B.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        if [ "$TUNNEL_PORT" -ge 1 ] && [ "$TUNNEL_PORT" -le 10 ]; then
            print_error "Invalid port number. System ports 1-10 are reserved. Please enter a port between 11-65535"
        else
            print_error "Invalid port number. Please enter a port between 11-65535"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Question 3: Transport Protocol Selection
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} Which transport protocol do you want to use?"
    echo -e "${DIM}Select the transport protocol for the tunnel connection.${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}XHTTP (SplitHTTP) + Reality${NC} ${DIM}- Stealth HTTP-based transport (recommended)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}XHTTP (SplitHTTP)${NC} ${DIM}- HTTP-based transport without Reality (fast + CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}TCP Raw${NC} ${DIM}- Direct TCP connection (fastest, no encryption)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}4.${NC} ${WHITE}TCP + Reality${NC} ${DIM}- TCP with Reality encryption (stealth + fast)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}5.${NC} ${WHITE}WebSocket${NC} ${DIM}- WebSocket transport (good for CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}6.${NC} ${WHITE}GRPC${NC} ${DIM}- gRPC transport (good for CDN)${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter choice ${DIM}[1-6, default: 1]${NC}: \c"
    read TRANSPORT_CHOICE
    TRANSPORT_CHOICE="${TRANSPORT_CHOICE:-1}"
    
    case $TRANSPORT_CHOICE in
        1)
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=true
            ;;
        2)
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=false
            ;;
        3)
            TRANSPORT_PROTOCOL="tcp"
            USE_REALITY=false
            ;;
        4)
            TRANSPORT_PROTOCOL="tcp"
            USE_REALITY=true
            ;;
        5)
            TRANSPORT_PROTOCOL="ws"
            USE_REALITY=false
            ;;
        6)
            TRANSPORT_PROTOCOL="grpc"
            USE_REALITY=false
            ;;
        *)
            print_warning "Invalid choice, using XHTTP (SplitHTTP) + Reality"
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=true
            ;;
    esac
    print_success "Transport Protocol: ${CYAN}${TRANSPORT_PROTOCOL}${NC}"
    
    # Question 4: Client Ports (ports that Server A will listen on)
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} Which ports should Server A listen on for client connections?"
    echo -e "${DIM}Enter ports separated by commas (e.g., 80,443,8080,8443).${NC}"
    echo -e "${DIM}These are the ports that clients will connect to on Server A.${NC}"
    echo -e "${DIM}Traffic on these ports will be forwarded through the tunnel to Server B.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter client ports ${DIM}[80,443,8080,8443]${NC}: \c"
    read CLIENT_PORTS_INPUT
    CLIENT_PORTS_INPUT="${CLIENT_PORTS_INPUT:-80,443,8080,8443}"
    
    # Validate all ports
    IFS=',' read -ra PORT_ARRAY <<< "$CLIENT_PORTS_INPUT"
    VALID_PORTS=""
    INVALID_COUNT=0
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ -z "$port" ]; then
            continue
        fi
        if validate_port "$port"; then
            if [ -z "$VALID_PORTS" ]; then
                VALID_PORTS="$port"
            else
                VALID_PORTS="$VALID_PORTS,$port"
            fi
        else
            INVALID_COUNT=$((INVALID_COUNT + 1))
            if [ "$port" -ge 1 ] && [ "$port" -le 10 ]; then
                print_error "Invalid port: $port (system ports 1-10 are reserved, skipping)"
            else
                print_error "Invalid port: $port (must be between 11-65535, skipping)"
            fi
        fi
    done
    
    if [ -z "$VALID_PORTS" ]; then
        print_error "No valid ports provided. Using defaults: 80,443,8080,8443"
        CLIENT_PORTS="80,443,8080,8443"
    else
        CLIENT_PORTS="$VALID_PORTS"
        if [ "$INVALID_COUNT" -gt 0 ]; then
            print_warning "Some ports were invalid and skipped. Using valid ports: $CLIENT_PORTS"
        fi
    fi
    print_success "Client Ports: ${CYAN}${CLIENT_PORTS}${NC}"
    
    # Question 5: Domain (for WebSocket/XHTTP) or Path (for GRPC) or Server Name (for Reality)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        # For XHTTP (SplitHTTP), always ask for domain name for CDN support
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What domain name should be used for XHTTP tunnel?"
        echo -e "${DIM}XHTTP requires a domain name (not IP) for CDN support and maximum speed.${NC}"
        echo -e "${DIM}This domain should point to Server B's IP address.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter domain name (e.g., example.com): \c"
        read XHTTP_DOMAIN
        if [ -z "$XHTTP_DOMAIN" ]; then
            print_error "Domain name is required for XHTTP. Please enter a valid domain."
            exit 1
        fi
        # Validate domain format (basic check)
        if ! echo "$XHTTP_DOMAIN" | grep -qE '^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'; then
            print_warning "Domain format may be invalid, but continuing..."
        fi
        print_success "Domain: ${CYAN}${XHTTP_DOMAIN}${NC}"
        
        # Update SERVER_B_IP to use domain instead of IP
        SERVER_B_IP="$XHTTP_DOMAIN"
        
        # If using Reality, ask for server name
        if [ "$USE_REALITY" = true ]; then
            echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 6:${NC} What server name should be used for Reality protocol (SNI)?"
            echo -e "${DIM}This is used to disguise the connection as legitimate traffic.${NC}"
            echo -e "${CYAN}${ARROW}${NC} Enter Reality server name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
            read SERVER_NAME
            SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
            print_success "Reality Server Name: ${CYAN}${SERVER_NAME}${NC}"
        else
            SERVER_NAME=""
        fi
        TRANSPORT_PATH="/assets"
        WS_DOMAIN=""
    elif [ "$USE_REALITY" = true ]; then
        # For other protocols with Reality, ask for server name
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What server name should be used for Reality protocol (SNI)?"
        echo -e "${DIM}This is used to disguise the connection as legitimate traffic.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Reality server name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
        read SERVER_NAME
        SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
        print_success "Reality Server Name: ${CYAN}${SERVER_NAME}${NC}"
        TRANSPORT_PATH="/assets"
        WS_DOMAIN=""
        XHTTP_DOMAIN=""
    else
        if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
            # For WebSocket, ask for domain name (required for CDN support)
            echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What domain name should be used for WebSocket?"
            echo -e "${DIM}WebSocket requires a domain name (not IP) for CDN support.${NC}"
            echo -e "${DIM}This domain should point to Server B's IP address.${NC}"
            echo -e "${CYAN}${ARROW}${NC} Enter domain name (e.g., example.com): \c"
            read WS_DOMAIN
            if [ -z "$WS_DOMAIN" ]; then
                print_error "Domain name is required for WebSocket. Please enter a valid domain."
                exit 1
            fi
            # Validate domain format (basic check)
            if ! echo "$WS_DOMAIN" | grep -qE '^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'; then
                print_warning "Domain format may be invalid, but continuing..."
            fi
            print_success "Domain: ${CYAN}${WS_DOMAIN}${NC}"
            
            # Update SERVER_B_IP to use domain instead of IP
            SERVER_B_IP="$WS_DOMAIN"
            
            # Ask for WebSocket path
            echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 6:${NC} What path should be used for WebSocket?"
            echo -e "${DIM}This is the HTTP path for WebSocket connections.${NC}"
            echo -e "${CYAN}${ARROW}${NC} Enter WebSocket path ${DIM}[/assets]${NC}: \c"
            read TRANSPORT_PATH
            TRANSPORT_PATH="${TRANSPORT_PATH:-/assets}"
            print_success "Path: ${CYAN}${TRANSPORT_PATH}${NC}"
        elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
            echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What service name should be used for GRPC?"
            echo -e "${DIM}This is the GRPC service name.${NC}"
            echo -e "${CYAN}${ARROW}${NC} Enter GRPC service name ${DIM}[/xray.XrayService]${NC}: \c"
            read TRANSPORT_PATH
            TRANSPORT_PATH="${TRANSPORT_PATH:-/xray.XrayService}"
            print_success "Service Name: ${CYAN}${TRANSPORT_PATH}${NC}"
            WS_DOMAIN=""
        else
            TRANSPORT_PATH=""
            WS_DOMAIN=""
        fi
        SERVER_NAME=""
    fi
    
    # Generate keys only if using Reality
    # Note: XHTTP without Reality doesn't need keys
    if [ "$USE_REALITY" = true ]; then
        generate_reality_keys
    else
        PUBLIC_KEY=""
        PRIVATE_KEY=""
        SHORT_IDS=""
        SHORT_ID=""
    fi
    
    # Generate UUID
    UUID=$(generate_uuid)
    print_success "Generated UUID: ${CYAN}${UUID}${NC}"
    
    # Generate seed for post-quantum cryptography (only for TCP + Reality)
    SEED=""
    if [ "$TRANSPORT_PROTOCOL" = "tcp" ] && [ "$USE_REALITY" = true ] && command -v xray >/dev/null 2>&1; then
        SEED_OUTPUT=$(xray mlkem768 2>&1)
        SEED=$(echo "$SEED_OUTPUT" | grep -i "Seed" | sed 's/.*Seed:[[:space:]]*//' | sed 's/[[:space:]]*$//' | head -1)
        if [ -z "$SEED" ]; then
            SEED=$(echo "$SEED_OUTPUT" | grep -oE '[A-Za-z0-9+/_-]{43}={0,1}' | head -1)
        fi
        if [ -n "$SEED" ] && [ ${#SEED} -ge 40 ]; then
            export SEED
            print_success "Generated seed for post-quantum cryptography: ${CYAN}${SEED}${NC}"
        fi
    fi
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    if [ "$TRANSPORT_PROTOCOL" = "ws" ] || [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        print_config_item "Server B Domain" "$SERVER_B_IP"
    else
        print_config_item "Server B IP" "$SERVER_B_IP"
    fi
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Client Ports" "$CLIENT_PORTS"
    print_config_item "Transport Protocol" "$TRANSPORT_PROTOCOL"
    if [ -n "$TRANSPORT_PATH" ]; then
        print_config_item "Transport Path" "$TRANSPORT_PATH"
    fi
    if [ -n "$WS_DOMAIN" ]; then
        print_config_item "WebSocket Domain" "$WS_DOMAIN"
    fi
    if [ -n "$XHTTP_DOMAIN" ]; then
        print_config_item "XHTTP Domain" "$XHTTP_DOMAIN"
    fi
    if [ "$USE_REALITY" = true ]; then
        print_config_item "Server Name" "$SERVER_NAME"
        print_config_item "Public Key (for Server A)" "$PUBLIC_KEY"
        print_config_item "Private Key (for Server B)" "$PRIVATE_KEY"
        print_config_item "Short ID" "$SHORT_ID"
        if [ -n "$SEED" ]; then
            print_config_item "Seed (for Server B)" "$SEED"
        fi
    fi
    print_config_item "UUID" "$UUID"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server A installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray
    print_section "Installing Xray"
    if ! command -v xray >/dev/null 2>&1; then
        install_xray_offline
    else
        print_success "Xray is already installed"
        CURRENT_VERSION=$(xray version | head -1)
        print_info "Current Xray version: ${CYAN}${CURRENT_VERSION}${NC}"
        print_info "Version check skipped during installation (use option 3 in main menu to check for updates)"
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Set proper permissions for log directory
    # Allow xray service to write logs
    chown -R root:root /var/log/xray
    chmod -R 755 /var/log/xray
    
    # Generate Server A configuration - build JSON directly without placeholders
    TEMP_CONFIG_A=$(mktemp)
    
    # Build inbounds array
    INBOUNDS_JSON=""
    IFS=',' read -ra PORT_ARRAY <<< "$CLIENT_PORTS"
    FIRST_INBOUND=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_INBOUND" = true ]; then
            FIRST_INBOUND=false
        else
            INBOUNDS_JSON="$INBOUNDS_JSON,"
        fi
        INBOUNDS_JSON="${INBOUNDS_JSON}
    {
      \"tag\": \"entry-${port}\",
      \"listen\": \"0.0.0.0\",
      \"port\": ${port},
      \"protocol\": \"dokodemo-door\",
      \"settings\": { \"address\": \"127.0.0.1\", \"port\": ${port}, \"network\": \"tcp\" }
    }"
    done
    
    # Build routing rules array
    ROUTING_RULES_JSON=""
    FIRST_RULE=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_RULE" = true ]; then
            FIRST_RULE=false
        else
            ROUTING_RULES_JSON="$ROUTING_RULES_JSON,"
        fi
        ROUTING_RULES_JSON="${ROUTING_RULES_JSON}
      { \"type\": \"field\", \"inboundTag\": [\"entry-${port}\"], \"outboundTag\": \"to-b\" }"
    done
    
    # Determine if flow is needed (only for TCP + Reality, not TCP Raw)
    # Flow must be set BEFORE building the config file
    if [ "$TRANSPORT_PROTOCOL" = "tcp" ] && [ "$USE_REALITY" = true ]; then
        FLOW_CONFIG=', "flow": "xtls-rprx-vision"'
    else
        FLOW_CONFIG=""
    fi
    
    # Use seed for post-quantum cryptography (already generated above)
    SEED_CONFIG=""
    if [ "$TRANSPORT_PROTOCOL" = "tcp" ] && [ "$USE_REALITY" = true ] && [ -n "$SEED" ]; then
        SEED_CONFIG=", \"seed\": \"$SEED\""
    fi
    
    # Build complete config file directly
    cat > "$TEMP_CONFIG_A" << EOF
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [$INBOUNDS_JSON
  ],
  "outbounds": [
    {
      "tag": "to-b",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "$SERVER_B_IP",
            "port": $TUNNEL_PORT,
            "users": [
              { "id": "$UUID", "encryption": "none"$FLOW_CONFIG$SEED_CONFIG }
            ]
          }
        ]
      },
      "streamSettings": {
STREAM_SETTINGS_PLACEHOLDER
      }
    },
    { "protocol": "freedom", "tag": "direct" }
  ],
  "routing": {
    "domainStrategy": "AsIs",
    "rules": [$ROUTING_RULES_JSON
    ]
  }
}
EOF
    
    # Build streamSettings based on transport protocol
    STREAM_SETTINGS_TEMP=$(mktemp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        if [ "$USE_REALITY" = true ]; then
            # XHTTP + Reality configuration for Server A (outbound)
            FIRST_SHORT_ID="$SHORT_ID"
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "serverName": "$SERVER_NAME",
          "publicKey": "$PUBLIC_KEY",
          "shortId": "$FIRST_SHORT_ID",
          "fingerprint": "chrome",
          "spiderX": "/"
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 4194304,
          "scMaxConcurrentPosts": 8,
          "scMinPostsIntervalMs": 10,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 0,
          "keepaliveperiod": 120,
          "mode": "packet-up"
        }
EOF
        else
            # XHTTP without Reality configuration for Server A (outbound)
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "splithttp",
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 4194304,
          "scMaxConcurrentPosts": 8,
          "scMinPostsIntervalMs": 10,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 0,
          "keepaliveperiod": 120,
          "mode": "packet-up"
        }
EOF
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "tcp" ]; then
        if [ "$USE_REALITY" = true ]; then
            # TCP + Reality configuration for Server A (outbound)
            FIRST_SHORT_ID="$SHORT_ID"
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "serverName": "$SERVER_NAME",
          "publicKey": "$PUBLIC_KEY",
          "shortId": "$FIRST_SHORT_ID",
          "fingerprint": "chrome",
          "spiderX": "/"
        },
        "tcpSettings": {
          "acceptProxyProtocol": false,
          "header": {
            "type": "none"
          }
        }
EOF
        else
            # TCP Raw (no encryption)
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "tcp",
        "tcpSettings": {
          "acceptProxyProtocol": false,
          "header": {
            "type": "none"
          }
        }
EOF
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        # WebSocket requires domain name in host field (for Server A outbound)
        if [ -n "$WS_DOMAIN" ]; then
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "ws",
        "wsSettings": {
          "path": "$TRANSPORT_PATH",
          "host": "$WS_DOMAIN"
        }
EOF
        else
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "ws",
        "wsSettings": {
          "path": "$TRANSPORT_PATH"
        }
EOF
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        # Server A (outbound) - optimized with performance settings
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "grpc",
        "grpcSettings": {
          "serviceName": "$TRANSPORT_PATH",
          "multiMode": true,
          "idle_timeout": 60,
          "health_check_timeout": 20,
          "permit_without_stream": false,
          "initial_windows_size": 65535
        }
EOF
    fi
    
    # Replace placeholders (FLOW_CONFIG and SEED_CONFIG already set above)
    sed -i "s/SERVER_B_IP_PLACEHOLDER/$SERVER_B_IP/g" "$TEMP_CONFIG_A"
    sed -i "s/TUNNEL_PORT_PLACEHOLDER/$TUNNEL_PORT/g" "$TEMP_CONFIG_A"
    sed -i "s/UUID_PLACEHOLDER/$UUID/g" "$TEMP_CONFIG_A"
    sed -i "s/\$FLOW_CONFIG/$FLOW_CONFIG/g" "$TEMP_CONFIG_A"
    
    # Replace streamSettings placeholder with actual settings
    # Use sed with r command to insert file content (safer for multiline)
    sed -i "/STREAM_SETTINGS_PLACEHOLDER/r $STREAM_SETTINGS_TEMP" "$TEMP_CONFIG_A"
    sed -i "/STREAM_SETTINGS_PLACEHOLDER/d" "$TEMP_CONFIG_A"
    
    # Move to final location
    mv "$TEMP_CONFIG_A" /etc/xray/a.json
    rm -f "$STREAM_SETTINGS_TEMP"
    
    # Set permissions
    chown root:root /etc/xray/a.json
    chmod 644 /etc/xray/a.json
    print_success "Configuration file created: /etc/xray/a.json"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Service"
    cat > /etc/systemd/system/xray-a.service << 'EOF'
[Unit]
Description=Xray Service (Server A)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
Type=simple
User=root
Group=root
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/a.json
Restart=on-failure
RestartSec=5s
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Configure firewall for client ports
    print_section "Configuring Firewall"
    print_info "Configuring firewall for client ports..."
    if command -v ufw >/dev/null 2>&1; then
        ufw allow 22/tcp
        IFS=',' read -ra PORT_ARRAY <<< "$CLIENT_PORTS"
        for port in "${PORT_ARRAY[@]}"; do
            port=$(echo "$port" | xargs) # trim whitespace
            ufw allow "$port/tcp"
        done
        print_success "Firewall configured for client ports: $CLIENT_PORTS"
    else
        print_warning "UFW not found. Please configure firewall manually for ports: $CLIENT_PORTS"
    fi
    print_section_end
    
    # Configure BBR and TCP optimizations
    print_section "Configuring Network Optimizations"
    configure_bbr_and_tcp
    print_section_end
    
    # Reload systemd and start service
    systemctl daemon-reload
    systemctl enable xray-a
    systemctl restart xray-a
    print_success "Service created and started: xray-a.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server A installation completed successfully!"
    echo
    print_info "Configuration saved to: /etc/xray/a.json"
    print_info "Service: xray-a.service"
    print_info "Logs location: /var/log/xray/"
    echo
    print_warning "IMPORTANT: Save these details for Server B installation:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}UUID:${NC} ${CYAN}${UUID}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Transport Protocol:${NC} ${CYAN}${TRANSPORT_PROTOCOL}${NC}"
    if [ "$TRANSPORT_PROTOCOL" = "ws" ] && [ -n "$WS_DOMAIN" ]; then
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Domain (for Server B):${NC} ${CYAN}${WS_DOMAIN}${NC}"
    fi
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ] && [ -n "$XHTTP_DOMAIN" ]; then
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Domain (for Server B):${NC} ${CYAN}${XHTTP_DOMAIN}${NC}"
    fi
    if [ -n "$TRANSPORT_PATH" ]; then
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Transport Path:${NC} ${CYAN}${TRANSPORT_PATH}${NC}"
    fi
    if [ "$USE_REALITY" = true ]; then
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key (for Server B):${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short ID:${NC} ${CYAN}${SHORT_ID}${NC}"
        if [ -n "$SEED" ]; then
            echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Seed (for Server B):${NC} ${CYAN}${SEED}${NC}"
        fi
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Server Name:${NC} ${CYAN}${SERVER_NAME}${NC}"
    fi
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Tunnel Port:${NC} ${CYAN}${TUNNEL_PORT}${NC}"
    echo
    if [ "$USE_REALITY" = true ]; then
        print_info "Note: Public Key is already configured in Server A, Private Key and Seed go to Server B"
    fi
    print_section_end
}

# Function to install Server B
install_server_b() {
    print_section "Server B Configuration"
    
    print_info "I will ask you for each configuration detail one by one."
    echo
    print_warning "You need the details from Server A installation first!"
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: UUID from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the UUID from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter UUID: \c"
    read UUID
    if [ -z "$UUID" ]; then
        print_error "UUID is required. Please enter the UUID from Server A."
        exit 1
    fi
    print_success "UUID: ${CYAN}${UUID}${NC}"
    
    # Question 2: Transport Protocol from Server A (must be asked first!)
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What transport protocol was used on Server A?"
    echo -e "${DIM}This should match the transport protocol selected on Server A.${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}XHTTP (SplitHTTP) + Reality${NC} ${DIM}- With Reality (recommended for stealth)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}XHTTP (SplitHTTP)${NC} ${DIM}- Without Reality (fast + CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}TCP Raw${NC} ${DIM}- Without TLS (fastest)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}4.${NC} ${WHITE}TCP + Reality${NC} ${DIM}- TCP with Reality encryption${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}5.${NC} ${WHITE}WebSocket${NC} ${DIM}- Without TLS (suitable for CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}6.${NC} ${WHITE}GRPC${NC} ${DIM}- Without TLS (suitable for CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter choice ${DIM}[1-6, default: 1]${NC}: \c"
    read TRANSPORT_CHOICE
    TRANSPORT_CHOICE="${TRANSPORT_CHOICE:-1}"
    
    case $TRANSPORT_CHOICE in
        1)
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=true
            ;;
        2)
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=false
            ;;
        3)
            TRANSPORT_PROTOCOL="tcp"
            USE_REALITY=false
            ;;
        4)
            TRANSPORT_PROTOCOL="tcp"
            USE_REALITY=true
            ;;
        5)
            TRANSPORT_PROTOCOL="ws"
            USE_REALITY=false
            ;;
        6)
            TRANSPORT_PROTOCOL="grpc"
            USE_REALITY=false
            ;;
        *)
            print_warning "Invalid choice, using XHTTP (SplitHTTP) + Reality"
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=true
            ;;
    esac
    print_success "Transport Protocol: ${CYAN}${TRANSPORT_PROTOCOL}${NC}"
    
    # Question 3: Domain (for XHTTP) or Private Key (for other Reality protocols)
    XHTTP_DOMAIN=""
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} What domain name was used on Server A?"
        echo -e "${DIM}This is the domain name used for XHTTP tunnel on Server A.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter domain name: \c"
        read XHTTP_DOMAIN
        if [ -z "$XHTTP_DOMAIN" ]; then
            print_error "Domain name is required for XHTTP. Please enter the domain from Server A."
            exit 1
        fi
        print_success "Domain: ${CYAN}${XHTTP_DOMAIN}${NC}"
    fi
    
    # Question 3/4: Private Key (only if using Reality with XHTTP or other protocols)
    if [ "$USE_REALITY" = true ]; then
        if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
            QUESTION_NUM="4"
        else
            QUESTION_NUM="3"
        fi
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What is the Private Key from Server A installation?"
        echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Private Key: \c"
        read SERVER_B_PRIVATE_KEY
        if [ -z "$SERVER_B_PRIVATE_KEY" ]; then
            print_error "Private Key is required. Please enter the Private Key from Server A."
            exit 1
        fi
        print_success "Private Key: ${CYAN}${SERVER_B_PRIVATE_KEY}${NC}"
    else
        SERVER_B_PRIVATE_KEY=""
    fi
    
    # Question 4: Domain and Path (if WebSocket) or Service Name (if GRPC)
    WS_DOMAIN=""
    if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        # For WebSocket, ask for domain name first
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} What domain name was used on Server A?"
        echo -e "${DIM}This is the domain name used for WebSocket on Server A.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter domain name: \c"
        read WS_DOMAIN
        if [ -z "$WS_DOMAIN" ]; then
            print_error "Domain name is required for WebSocket. Please enter the domain from Server A."
            exit 1
        fi
        print_success "Domain: ${CYAN}${WS_DOMAIN}${NC}"
        
        # Then ask for WebSocket path
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What path was used on Server A?"
        echo -e "${DIM}This is the WebSocket path used on Server A.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter WebSocket path ${DIM}[/assets]${NC}: \c"
        read TRANSPORT_PATH
        TRANSPORT_PATH="${TRANSPORT_PATH:-/assets}"
        print_success "Path: ${CYAN}${TRANSPORT_PATH}${NC}"
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} What service name was used on Server A?"
        echo -e "${DIM}This is the GRPC service name used on Server A.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter GRPC service name ${DIM}[/xray.XrayService]${NC}: \c"
        read TRANSPORT_PATH
        TRANSPORT_PATH="${TRANSPORT_PATH:-/xray.XrayService}"
        print_success "Service Name: ${CYAN}${TRANSPORT_PATH}${NC}"
    else
        TRANSPORT_PATH=""
    fi
    
    # Question 5/6/7: Short IDs (only if using Reality)
    if [ "$USE_REALITY" = true ]; then
        if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
            QUESTION_NUM="6"
        elif [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
            QUESTION_NUM="5"
        else
            QUESTION_NUM="5"
        fi
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What is the Short ID from Server A installation?"
        echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Short ID: \c"
        read SERVER_B_SHORT_ID
        if [ -z "$SERVER_B_SHORT_ID" ]; then
            print_error "Short ID is required. Please enter the Short ID from Server A."
            exit 1
        fi
        # Remove quotes if user entered them
        SERVER_B_SHORT_ID=$(echo "$SERVER_B_SHORT_ID" | sed 's/"//g' | xargs)
        SERVER_B_SHORT_IDS="\"$SERVER_B_SHORT_ID\""
        print_success "Short ID: ${CYAN}${SERVER_B_SHORT_ID}${NC}"
    else
        SERVER_B_SHORT_IDS=""
    fi
    
    # Question 6: Seed (only for TCP + Reality)
    SERVER_B_SEED=""
    if [ "$TRANSPORT_PROTOCOL" = "tcp" ] && [ "$USE_REALITY" = true ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 6:${NC} What is the Seed from Server A installation?"
        echo -e "${DIM}This was generated and shown to you during Server A setup (for TCP + Reality).${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Seed: \c"
        read SERVER_B_SEED
        if [ -z "$SERVER_B_SEED" ]; then
            print_error "Seed is required for TCP + Reality. Please enter the Seed from Server A."
            exit 1
        fi
        # Remove quotes if user entered them
        SERVER_B_SEED=$(echo "$SERVER_B_SEED" | sed 's/"//g' | xargs)
        print_success "Seed: ${CYAN}${SERVER_B_SEED}${NC}"
    fi
    
    # Question 6/7/8: Server Name (only if using Reality)
    if [ "$USE_REALITY" = true ]; then
        if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
            QUESTION_NUM="7"
        elif [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
            QUESTION_NUM="6"
        else
            QUESTION_NUM="7"
        fi
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What is the Server Name from Server A installation?"
        echo -e "${DIM}This is the Reality server name (SNI) you used on Server A.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Server Name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
        read SERVER_NAME
        SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
        print_success "Server Name: ${CYAN}${SERVER_NAME}${NC}"
    else
        SERVER_NAME=""
    fi
    
    # Tunnel Port from Server A (question number depends on transport protocol)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        if [ "$USE_REALITY" = true ]; then
            QUESTION_NUM="7"
        else
            QUESTION_NUM="4"
        fi
    elif [ "$USE_REALITY" = true ]; then
        QUESTION_NUM="8"
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        QUESTION_NUM="6"
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        QUESTION_NUM="5"
    else
        QUESTION_NUM="3"
    fi
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What is the Tunnel Port from Server A installation?"
    echo -e "${DIM}This is the port you used for VLESS connection on Server A.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        if [ "$TUNNEL_PORT" -ge 1 ] && [ "$TUNNEL_PORT" -le 10 ]; then
            print_error "Invalid port number. System ports 1-10 are reserved. Please enter a port between 11-65535"
        else
            print_error "Invalid port number. Please enter a port between 11-65535"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Ports to forward (question number depends on transport protocol)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        if [ "$USE_REALITY" = true ]; then
            QUESTION_NUM="8"
        else
            QUESTION_NUM="5"
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        QUESTION_NUM="7"
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        QUESTION_NUM="6"
    else
        QUESTION_NUM="4"
    fi
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What ports should Server B forward traffic to?"
    echo -e "${DIM}Enter ports separated by commas (e.g., 80,8080,8443).${NC}"
    echo -e "${DIM}Traffic from Server A on port 80 will be forwarded to 127.0.0.1:80${NC}"
    echo -e "${DIM}Traffic from Server A on port 8080 will be forwarded to 127.0.0.1:8080${NC}"
    echo -e "${DIM}Ports are preserved - same port in = same port out${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter ports ${DIM}[80,8080,8443]${NC}: \c"
    read ASSIGNED_PORTS
    ASSIGNED_PORTS="${ASSIGNED_PORTS:-80,8080,8443}"
    
    # Validate all ports
    IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
    VALID_PORTS=""
    INVALID_COUNT=0
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ -z "$port" ]; then
            continue
        fi
        if validate_port "$port"; then
            if [ -z "$VALID_PORTS" ]; then
                VALID_PORTS="$port"
            else
                VALID_PORTS="$VALID_PORTS,$port"
            fi
        else
            INVALID_COUNT=$((INVALID_COUNT + 1))
            if [ "$port" -ge 1 ] && [ "$port" -le 10 ]; then
                print_error "Invalid port: $port (system ports 1-10 are reserved, skipping)"
            else
                print_error "Invalid port: $port (must be between 11-65535, skipping)"
            fi
        fi
    done
    
    if [ -z "$VALID_PORTS" ]; then
        print_error "No valid ports provided. Using defaults: 80,8080,8443"
        ASSIGNED_PORTS="80,8080,8443"
    else
        ASSIGNED_PORTS="$VALID_PORTS"
        if [ "$INVALID_COUNT" -gt 0 ]; then
            print_warning "Some ports were invalid and skipped. Using valid ports: $ASSIGNED_PORTS"
        fi
    fi
    print_success "Ports to forward: ${CYAN}${ASSIGNED_PORTS}${NC}"
    print_info "Traffic will be forwarded to 127.0.0.1:<same-port>"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "UUID" "$UUID"
    print_config_item "Transport Protocol" "$TRANSPORT_PROTOCOL"
    if [ -n "$TRANSPORT_PATH" ]; then
        print_config_item "Transport Path" "$TRANSPORT_PATH"
    fi
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        if [ -n "$XHTTP_DOMAIN" ]; then
            print_config_item "Domain" "$XHTTP_DOMAIN"
        fi
        if [ "$USE_REALITY" = true ]; then
            print_config_item "Private Key" "$SERVER_B_PRIVATE_KEY"
            print_config_item "Short ID" "$SERVER_B_SHORT_ID"
            if [ -n "$SERVER_B_SEED" ]; then
                print_config_item "Seed" "$SERVER_B_SEED"
            fi
            print_config_item "Server Name" "$SERVER_NAME"
        fi
    fi
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Ports to Forward" "$ASSIGNED_PORTS"
    print_info "Port routing: Each port forwards to 127.0.0.1:<same-port>"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server B installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray only (no nginx)
    print_section "Installing Services"
    if ! command -v xray >/dev/null 2>&1; then
        install_xray_offline
    else
        print_success "Xray is already installed"
        CURRENT_VERSION=$(xray version | head -1)
        print_info "Current Xray version: ${CYAN}${CURRENT_VERSION}${NC}"
        print_info "Version check skipped during installation (use option 3 in main menu to check for updates)"
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Set proper permissions for log directory
    # Allow xray service (running as root) to write logs
    chown -R root:root /var/log/xray
    chmod -R 755 /var/log/xray
    
    # Determine if flow is needed (only for TCP + Reality, not TCP Raw)
    # Flow must be set BEFORE building the config file
    if [ "$TRANSPORT_PROTOCOL" = "tcp" ] && [ "$USE_REALITY" = true ]; then
        FLOW_CONFIG=', "flow": "xtls-rprx-vision"'
    else
        FLOW_CONFIG=""
    fi
    
    # Use seed from Server A (already provided by user)
    SEED_CONFIG=""
    if [ "$TRANSPORT_PROTOCOL" = "tcp" ] && [ "$USE_REALITY" = true ] && [ -n "$SERVER_B_SEED" ]; then
        SEED_CONFIG=", \"seed\": \"$SERVER_B_SEED\""
    fi
    
    # Generate Server B configuration with port-preserving routing
    TEMP_CONFIG=$(mktemp)
    
    # Start with base config
    cat > "$TEMP_CONFIG" << BASEEOF
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "tag": "tunnel-in",
      "listen": "0.0.0.0",
      "port": TUNNEL_PORT_PLACEHOLDER,
      "protocol": "vless",
      "settings": {
        "clients": [
          { "id": "UUID_PLACEHOLDER"$FLOW_CONFIG$SEED_CONFIG }
        ],
        "decryption": "none"
      },
      "streamSettings": {
STREAM_SETTINGS_PLACEHOLDER
      }
    }
  ],
  "outbounds": [
BASEEOF
    
    # Create outbounds for each port (port-preserving)
    IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
    FIRST_OUTBOUND=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_OUTBOUND" = true ]; then
            FIRST_OUTBOUND=false
        else
            echo "," >> "$TEMP_CONFIG"
        fi
        cat >> "$TEMP_CONFIG" << OUTBOUNDEOF
    { "tag": "to-port-$port", "protocol": "freedom", "settings": { "redirect": "127.0.0.1:$port" } }
OUTBOUNDEOF
    done
    
    # Add routing rules
    cat >> "$TEMP_CONFIG" << ROUTINGEOF
  ],
  "routing": {
    "rules": [
ROUTINGEOF
    
    # Add routing rules for each port (port-preserving)
    FIRST_RULE=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_RULE" = true ]; then
            FIRST_RULE=false
        else
            echo "," >> "$TEMP_CONFIG"
        fi
        cat >> "$TEMP_CONFIG" << RULEEOF
      { "type": "field", "inboundTag": ["tunnel-in"], "port": $port, "outboundTag": "to-port-$port" }
RULEEOF
    done
    
    cat >> "$TEMP_CONFIG" << ENDEOF
    ]
  }
}
ENDEOF
    
    # Build streamSettings based on transport protocol
    STREAM_SETTINGS_TEMP=$(mktemp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        if [ "$USE_REALITY" = true ]; then
            # XHTTP + Reality configuration for Server B (inbound)
            FORMATTED_SHORT_ID=$(echo "$SERVER_B_SHORT_IDS" | sed 's/"//g' | xargs)
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "www.microsoft.com:443",
          "serverNames": ["$SERVER_NAME"],
          "privateKey": "$SERVER_B_PRIVATE_KEY",
          "shortIds": ["$FORMATTED_SHORT_ID"]
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 4194304,
          "scMaxConcurrentPosts": 8,
          "scMinPostsIntervalMs": 10,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 0,
          "keepaliveperiod": 120,
          "mode": "packet-up"
        }
EOF
        else
            # XHTTP without Reality configuration for Server B (inbound)
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "splithttp",
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 4194304,
          "scMaxConcurrentPosts": 8,
          "scMinPostsIntervalMs": 10,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 0,
          "keepaliveperiod": 120,
          "mode": "packet-up"
        }
EOF
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "tcp" ]; then
        if [ "$USE_REALITY" = true ]; then
            # TCP + Reality configuration for Server B (inbound)
            FORMATTED_SHORT_ID=$(echo "$SERVER_B_SHORT_IDS" | sed 's/"//g' | xargs)
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "www.microsoft.com:443",
          "serverNames": ["$SERVER_NAME"],
          "privateKey": "$SERVER_B_PRIVATE_KEY",
          "shortIds": ["$FORMATTED_SHORT_ID"]
        },
        "tcpSettings": {
          "acceptProxyProtocol": false,
          "header": {
            "type": "none"
          }
        }
EOF
        else
            # TCP Raw (no encryption)
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "tcp",
        "tcpSettings": {
          "acceptProxyProtocol": false,
          "header": {
            "type": "none"
          }
        }
EOF
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        # WebSocket requires domain name in host field (for Server B inbound)
        if [ -n "$WS_DOMAIN" ]; then
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "ws",
        "wsSettings": {
          "path": "$TRANSPORT_PATH",
          "host": "$WS_DOMAIN"
        }
EOF
        else
            cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "ws",
        "wsSettings": {
          "path": "$TRANSPORT_PATH"
        }
EOF
        fi
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        # Server B (inbound) - simpler config, no client-side optimizations
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "grpc",
        "grpcSettings": {
          "serviceName": "$TRANSPORT_PATH"
        }
EOF
    fi
    
    # Replace streamSettings placeholder
    sed -i "/STREAM_SETTINGS_PLACEHOLDER/r $STREAM_SETTINGS_TEMP" "$TEMP_CONFIG"
    sed -i "/STREAM_SETTINGS_PLACEHOLDER/d" "$TEMP_CONFIG"
    
    # Replace other placeholders
    sed -i "s/TUNNEL_PORT_PLACEHOLDER/$TUNNEL_PORT/g" "$TEMP_CONFIG"
    sed -i "s/UUID_PLACEHOLDER/$UUID/g" "$TEMP_CONFIG"
    
    # Cleanup
    rm -f "$STREAM_SETTINGS_TEMP"
    
    # Move temp config to final location
    mv "$TEMP_CONFIG" /etc/xray/b.json
    
    # Set permissions
    chown root:root /etc/xray/b.json
    chmod 644 /etc/xray/b.json
    print_success "Configuration file created: /etc/xray/b.json"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Services"
    cat > /etc/systemd/system/xray-b.service << 'EOF'
[Unit]
Description=Xray Service (Server B)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
Type=simple
User=root
Group=root
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/b.json
Restart=on-failure
RestartSec=5s
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Configure firewall for assigned ports
    print_info "Configuring firewall..."
    if command -v ufw >/dev/null 2>&1; then
        ufw allow 22/tcp
        ufw allow "$TUNNEL_PORT/tcp"
        IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
        for port in "${PORT_ARRAY[@]}"; do
            port=$(echo "$port" | xargs) # trim whitespace
            ufw allow "$port/tcp"
        done
        print_success "Firewall configured"
    else
        print_warning "UFW not found. Please configure firewall manually for ports: $ASSIGNED_PORTS"
    fi
    
    # Reload systemd and start service
    systemctl daemon-reload
    systemctl enable xray-b
    systemctl restart xray-b
    print_success "Service created and started: xray-b.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server B installation completed successfully!"
    echo
    print_info "Configuration files:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Xray config:${NC} /etc/xray/b.json"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Logs location:${NC} /var/log/xray/"
    echo
    print_success "Tunnel is now active!"
    print_info "Traffic routing (port-preserving):"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Tunnel Port ($TUNNEL_PORT):${NC} â†’ Receives tunneled traffic from Server A"
    IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Port $port:${NC} â†’ 127.0.0.1:$port"
    done
    print_section_end
}

# Function to show usage
show_usage() {
    print_header
    echo -e "${WHITE}${BOLD}Usage:${NC} bash install [tunnel-type] [server-type]"
    echo
    echo -e "${WHITE}${BOLD}Tunnel Types:${NC}"
    echo -e "  ${CYAN}xray${NC}     - Xray tunnel (default)"
    echo -e "  ${CYAN}paqet${NC}    - Paqet tunnel"
    echo
    echo -e "${WHITE}${BOLD}Server types (for Xray):${NC}"
    echo -e "  ${CYAN}a, server-a, tunnel${NC}    Install on Server A (Tunnel Server)"
    echo -e "  ${CYAN}b, server-b, dest${NC}     Install on Server B (Destination Server)"
    echo -e "  ${CYAN}auto${NC}                  Auto-detect server type (default)"
    echo
    echo -e "${WHITE}${BOLD}Examples:${NC}"
    echo -e "  ${DIM}bash install${NC}              # Interactive menu (select tunnel type)"
    echo -e "  ${DIM}bash install xray a${NC}       # Xray tunnel on Server A"
    echo -e "  ${DIM}bash install xray server-b${NC} # Xray tunnel on Server B"
    echo -e "  ${DIM}bash install paqet${NC}        # Paqet tunnel installer"
    echo -e "  ${DIM}bash install a${NC}            # Xray tunnel on Server A (default)"
    echo
    echo -e "${WHITE}${BOLD}Manual installation:${NC}"
    echo -e "  ${DIM}bash install_a.sh${NC}    # For Server A only (Xray)"
    echo -e "  ${DIM}bash install_b.sh${NC}    # For Server B only (Xray)"
}

# Function to run Paqet tunnel installer
run_paqet_installer() {
    local paqet_script=""
    
    # Check if paqet.sh exists locally
    if [ -f "$(dirname "$0")/paqet.sh" ]; then
        paqet_script="$(dirname "$0")/paqet.sh"
    elif [ -f "./paqet.sh" ]; then
        paqet_script="./paqet.sh"
    else
        # Download from GitHub
        print_info "Downloading Paqet installer from GitHub..."
        paqet_script="/tmp/paqet.sh"
        if curl -fsSL https://raw.githubusercontent.com/letmefind/stealth-multiplex-tunnel-xray/main/paqet.sh -o "$paqet_script" 2>/dev/null; then
            chmod +x "$paqet_script"
        else
            print_error "Failed to download Paqet installer"
            exit 1
        fi
    fi
    
    print_success "Starting Paqet tunnel installer..."
    echo ""
    exec bash "$paqet_script" "$@"
}

# Main function
main() {
    # Check for help first
    if [ $# -gt 0 ] && [[ "$1" =~ ^(--help|-h|help)$ ]]; then
        show_usage
        exit 0
    fi
    
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        print_error "Please run as root"
        exit 1
    fi
    
    # Tunnel type selection (only if no tunnel type specified)
    TUNNEL_TYPE=""
    if [ $# -gt 0 ] && [[ "$1" =~ ^(xray|paqet)$ ]]; then
        TUNNEL_TYPE="$1"
        shift # Remove tunnel type from arguments
    elif [ $# -eq 0 ] || [[ ! "$1" =~ ^(a|b|server-a|server-b|auto|tunnel|dest|destination)$ ]]; then
        # Show tunnel type menu
        show_tunnel_type_menu
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Enter your choice${NC} ${DIM}[1-3]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter choice: "
        read tunnel_choice
        
        case "$tunnel_choice" in
            1)
                TUNNEL_TYPE="xray"
                ;;
            2)
                TUNNEL_TYPE="paqet"
                ;;
            3)
                TUNNEL_TYPE="check-version"
                ;;
            *)
                print_error "Invalid choice"
                exit 1
                ;;
        esac
    else
        # Default to Xray if server type is specified directly
        TUNNEL_TYPE="xray"
    fi
    
    # If Paqet is selected, run Paqet installer
    if [ "$TUNNEL_TYPE" = "paqet" ]; then
        run_paqet_installer "$@"
        exit 0
    fi
    
    # Continue with Xray installation
    print_header
    
    # Determine server type
    SERVER_TYPE=""
    if [ $# -eq 0 ]; then
        # No arguments, show menu
        show_server_menu
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Enter your choice${NC} ${DIM}[1-3]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter choice: "
        read choice
        
        case "$choice" in
            1)
                SERVER_TYPE="a"
                ;;
            2)
                SERVER_TYPE="b"
                ;;
            3)
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Invalid choice"
                exit 1
                ;;
        esac
    else
        case "$1" in
            "a"|"server-a"|"tunnel")
                SERVER_TYPE="a"
                ;;
            "b"|"server-b"|"dest"|"destination")
                SERVER_TYPE="b"
                ;;
            "auto")
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Unknown server type: $1"
                show_usage
                exit 1
                ;;
        esac
    fi
    
    # Handle version check option
    if [ "$TUNNEL_TYPE" = "check-version" ]; then
        print_section "Check Xray Version"
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Enter Xray version to check:${NC}"
        echo -e "${DIM}Enter version number (e.g., v1.8.4 or 1.8.4)${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter version: \c"
        read VERSION_TO_CHECK
        if [ -z "$VERSION_TO_CHECK" ]; then
            print_error "Version not specified"
            exit 1
        fi
        check_specific_xray_version "$VERSION_TO_CHECK"
        exit 0
    fi
    
    print_info "Selected server type: Server $SERVER_TYPE"
    echo
    
    if [ "$SERVER_TYPE" = "a" ]; then
        install_server_a
    elif [ "$SERVER_TYPE" = "b" ]; then
        install_server_b
    else
        print_error "Could not determine server type"
        exit 1
    fi
}

# Run main function
main "$@"
