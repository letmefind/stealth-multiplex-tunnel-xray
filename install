#!/bin/bash

# VLESS+REALITY Tunnel Installation Script
# Modern Interactive Installation with Beautiful UI

set -e

# Debug mode - uncomment to enable debug output
# set -x

# Modern Color Palette
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;37m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# UI Elements
BOX_TOP="╭─────────────────────────────────────────────────────────╮"
BOX_BOTTOM="╰─────────────────────────────────────────────────────────╯"
BOX_SIDE="│"
ARROW="▶"
CHECK="✓"
CROSS="✗"
STAR="✦"
DOT="•"

# Function to print with modern styling
print_header() {
    echo -e "${CYAN}${BOLD}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                    🚀 VLESS+REALITY TUNNEL 🚀                ║"
    echo "║                   Modern Installation Script                ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

print_section() {
    local title="$1"
    echo -e "\n${PURPLE}${BOLD}${STAR} ${title}${NC}"
    echo -e "${PURPLE}${BOX_TOP}${NC}"
}

print_section_end() {
    echo -e "${PURPLE}${BOX_BOTTOM}${NC}"
}

print_info() {
    echo -e "${BLUE}${ARROW}${NC} ${1}"
}

print_success() {
    echo -e "${GREEN}${CHECK}${NC} ${1}"
}

print_warning() {
    echo -e "${YELLOW}${DOT}${NC} ${1}"
}

print_error() {
    echo -e "${RED}${CROSS}${NC} ${1}"
}

print_input() {
    echo -e "${CYAN}${ARROW}${NC} ${1}"
}

print_config_item() {
    local key="$1"
    local value="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC} ${CYAN}${value}${NC}"
}

# Function to show animated loading
show_loading() {
    local message="$1"
    local pid=$!
    local delay=0.1
    local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    
    echo -ne "${BLUE}${ARROW}${NC} ${message} "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Function to get user input with modern styling
get_input() {
    local prompt="$1"
    local default="$2"
    local value
    
    if [ -n "$default" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC} ${DIM}[${default}]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "${value:-$default}"
    else
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "$value"
    fi
}

# Function to show confirmation dialog
confirm() {
    local message="$1"
    local default="${2:-n}"
    
    if [ "$default" = "y" ]; then
        echo -e "\n${GREEN}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[Y/n]${NC}"
        echo -ne "${GREEN}${ARROW}${NC} Enter choice: "
    else
        echo -e "\n${YELLOW}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[y/N]${NC}"
        echo -ne "${YELLOW}${ARROW}${NC} Enter choice: "
    fi
    
    read -r response
    if [ "$default" = "y" ]; then
        [[ "$response" =~ ^[Nn]$ ]] && return 1 || return 0
    else
        [[ "$response" =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

# Function to generate UUID
generate_uuid() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    elif command -v python3 >/dev/null 2>&1; then
        python3 -c "import uuid; print(uuid.uuid4())"
    else
        cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "12345678-1234-1234-1234-123456789abc"
    fi
}

# Function to generate Reality keys
generate_reality_keys() {
    if command -v xray >/dev/null 2>&1; then
        KEYS=$(xray x25519 2>/dev/null)
        PUBLIC_KEY=$(echo "$KEYS" | grep "Public key:" | cut -d' ' -f3)
        PRIVATE_KEY=$(echo "$KEYS" | grep "Private key:" | cut -d' ' -f3)
        SHORT_ID=$(openssl rand -hex 8 2>/dev/null)
        
        # Debug: Check if keys were parsed correctly
        if [ -z "$PUBLIC_KEY" ] || [ -z "$PRIVATE_KEY" ]; then
            print_warning "Failed to parse Reality keys, using default keys"
            PUBLIC_KEY="wwgbwD3pK6aBzxtMzAyAdzV8430zraDqrCrH7tivDV4"
            PRIVATE_KEY="kEHlrW7KE0TxG_UhhOwE2YzMbzGlWign5rSrcweFVkY"
            SHORT_ID="db78ea236c7e33f5"
        else
            print_success "Generated Reality keys successfully"
        fi
        
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short ID:${NC} ${CYAN}${SHORT_ID}${NC}"
    else
        print_warning "Xray not found, using default keys"
        PUBLIC_KEY="wwgbwD3pK6aBzxtMzAyAdzV8430zraDqrCrH7tivDV4"
        PRIVATE_KEY="kEHlrW7KE0TxG_UhhOwE2YzMbzGlWign5rSrcweFVkY"
        SHORT_ID="db78ea236c7e33f5"
        
        print_success "Using default Reality keys"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short ID:${NC} ${CYAN}${SHORT_ID}${NC}"
    fi
    
    # Export the variables so they're available globally
    export PUBLIC_KEY
    export PRIVATE_KEY
    export SHORT_ID
}

# Function to validate port
validate_port() {
    local port="$1"
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        return 1
    fi
    return 0
}

# Function to validate IP
validate_ip() {
    local ip="$1"
    # More comprehensive IP validation
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Check each octet is between 0-255
        IFS='.' read -ra ADDR <<< "$ip"
        for i in "${ADDR[@]}"; do
            if [[ $i -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# Function to show server selection menu
show_server_menu() {
    print_section "Server Type Selection"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Choose your server type:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}Server A (Tunnel Server)${NC} ${DIM}- Receives traffic and forwards to Server B${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}Server B (Destination Server)${NC} ${DIM}- Receives tunneled traffic and routes to services${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}Auto-detect${NC} ${DIM}- Automatically detect server type${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    print_section_end
}

# Function to detect server type
detect_server_type() {
    print_info "Auto-detecting server type..." >&2
    
    if command -v nginx >/dev/null 2>&1; then
        echo "b"
    else
        echo "a"
    fi
}

# Function to install Server A
install_server_a() {
    print_section "Server A Configuration"
    
    # Get configuration from user
    print_info "I will ask you for each configuration detail one by one."
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: Server B IP
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the IP address of Server B (destination server)?"
    echo -e "${DIM}This is the server where your tunneled traffic will be sent.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
    read SERVER_B_IP
    
    while [ -z "$SERVER_B_IP" ] || ! validate_ip "$SERVER_B_IP"; do
        if [ -z "$SERVER_B_IP" ]; then
            print_error "Server B IP address is required. Please enter a valid IP address."
        else
            print_error "Invalid IP address format. Please enter a valid IP like 192.168.1.100"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
        read SERVER_B_IP
    done
    print_success "Server B IP: ${CYAN}${SERVER_B_IP}${NC}"
    
    # Question 2: Tunnel Port
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What port should be used for the VLESS tunnel connection?"
    echo -e "${DIM}This is the port that Server A will connect to on Server B.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        print_error "Invalid port number. Please enter a port between 1-65535"
        echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Question 3: Reality Server Name
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} What server name should be used for Reality protocol (SNI)?"
    echo -e "${DIM}This is used to disguise the connection as legitimate traffic.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Reality server name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
    read SERVER_NAME
    SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
    print_success "Reality Server Name: ${CYAN}${SERVER_NAME}${NC}"
    
    # Generate keys
    generate_reality_keys
    
    # Generate UUID
    UUID=$(generate_uuid)
    print_success "Generated UUID: ${CYAN}${UUID}${NC}"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "Server B IP" "$SERVER_B_IP"
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Server Name" "$SERVER_NAME"
    print_config_item "UUID" "$UUID"
    
    print_config_item "Public Key (for Server A)" "$PUBLIC_KEY"
    print_config_item "Private Key (for Server B)" "$PRIVATE_KEY"
    print_config_item "Short ID (for both servers)" "$SHORT_ID"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server A installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray
    print_section "Installing Xray"
    if ! command -v xray >/dev/null 2>&1; then
        print_info "Installing Xray..."
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
        print_success "Xray installed successfully"
    else
        print_success "Xray is already installed"
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Generate Server A configuration
    cat > /etc/xray/a.json << EOF
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "tag": "entry-80",
      "listen": "0.0.0.0",
      "port": 80,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 80, "network": "tcp" }
    },
    {
      "tag": "entry-443",
      "listen": "0.0.0.0",
      "port": 443,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 443, "network": "tcp" }
    },
    {
      "tag": "entry-8080",
      "listen": "0.0.0.0",
      "port": 8080,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 8080, "network": "tcp" }
    },
    {
      "tag": "entry-8443",
      "listen": "0.0.0.0",
      "port": 8443,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 8443, "network": "tcp" }
    }
  ],
  "outbounds": [
    {
      "tag": "to-b",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "$SERVER_B_IP",
            "port": $TUNNEL_PORT,
            "users": [
              { "id": "$UUID", "encryption": "none" }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "serverName": "$SERVER_NAME",
          "publicKey": "$PUBLIC_KEY",
          "shortId": "$SHORT_ID",
          "fingerprint": "chrome",
          "spiderX": "/"
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 1000000,
          "scMaxConcurrentPosts": 6,
          "scMinPostsIntervalMs": 25,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 200,
          "keepaliveperiod": 60,
          "mode": "auto"
        }
      }
    },
    { "protocol": "freedom", "tag": "direct" }
  ],
  "routing": {
    "domainStrategy": "AsIs",
    "rules": [
      { "type": "field", "inboundTag": ["entry-80"],   "outboundTag": "to-b" },
      { "type": "field", "inboundTag": ["entry-443"],  "outboundTag": "to-b" },
      { "type": "field", "inboundTag": ["entry-8080"], "outboundTag": "to-b" },
      { "type": "field", "inboundTag": ["entry-8443"], "outboundTag": "to-b" }
    ]
  }
}
EOF
    
    # Set permissions
    chown root:root /etc/xray/a.json
    chmod 644 /etc/xray/a.json
    print_success "Configuration file created: /etc/xray/a.json"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Service"
    cat > /etc/systemd/system/xray-a.service << 'EOF'
[Unit]
Description=Xray Service (Server A)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/a.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Reload systemd and start service
    systemctl daemon-reload
    systemctl enable xray-a
    systemctl restart xray-a
    print_success "Service created and started: xray-a.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server A installation completed successfully!"
    echo
    print_info "Configuration saved to: /etc/xray/a.json"
    print_info "Service: xray-a.service"
    print_info "Logs location: /var/log/xray/"
    echo
    print_warning "IMPORTANT: Save these details for Server B installation:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}UUID:${NC} ${CYAN}${UUID}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key (for Server B):${NC} ${CYAN}${PRIVATE_KEY}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short ID (for both servers):${NC} ${CYAN}${SHORT_ID}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Server Name:${NC} ${CYAN}${SERVER_NAME}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Tunnel Port:${NC} ${CYAN}${TUNNEL_PORT}${NC}"
    echo
    print_info "Note: Public Key is already configured in Server A, Private Key goes to Server B"
    print_section_end
}

# Function to install Server B
install_server_b() {
    print_section "Server B Configuration"
    
    print_info "I will ask you for each configuration detail one by one."
    echo
    print_warning "You need the details from Server A installation first!"
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: UUID from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the UUID from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter UUID: \c"
    read UUID
    if [ -z "$UUID" ]; then
        print_error "UUID is required. Please enter the UUID from Server A."
        exit 1
    fi
    print_success "UUID: ${CYAN}${UUID}${NC}"
    
    # Question 2: Private Key from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What is the Private Key from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Private Key: \c"
    read SERVER_B_PRIVATE_KEY
    if [ -z "$SERVER_B_PRIVATE_KEY" ]; then
        print_error "Private Key is required. Please enter the Private Key from Server A."
        exit 1
    fi
    print_success "Private Key: ${CYAN}${SERVER_B_PRIVATE_KEY}${NC}"
    
    # Question 3: Short ID from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} What is the Short ID from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Short ID: \c"
    read SERVER_B_SHORT_ID
    if [ -z "$SERVER_B_SHORT_ID" ]; then
        print_error "Short ID is required. Please enter the Short ID from Server A."
        exit 1
    fi
    print_success "Short ID: ${CYAN}${SERVER_B_SHORT_ID}${NC}"
    
    # Question 4: Server Name from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} What is the Server Name from Server A installation?"
    echo -e "${DIM}This is the Reality server name (SNI) you used on Server A.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Server Name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
    read SERVER_NAME
    SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
    print_success "Server Name: ${CYAN}${SERVER_NAME}${NC}"
    
    # Question 5: Tunnel Port from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What is the Tunnel Port from Server A installation?"
    echo -e "${DIM}This is the port you used for VLESS connection on Server A.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        print_error "Invalid port number. Please enter a port between 1-65535"
        echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Question 6: Target Port
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 6:${NC} What port do you want to tunnel to your local service?"
    echo -e "${DIM}This is the port of your local service (e.g., 8443 for XMPlus).${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter target port ${DIM}[8443]${NC}: \c"
    read TARGET_PORT
    TARGET_PORT="${TARGET_PORT:-8443}"
    
    while ! validate_port "$TARGET_PORT" || [ "$TARGET_PORT" = "80" ] || [ "$TARGET_PORT" = "443" ]; do
        if [ "$TARGET_PORT" = "80" ] || [ "$TARGET_PORT" = "443" ]; then
            print_error "Target port cannot be 80 or 443 (use nginx for these)"
        else
            print_error "Invalid port number. Please enter a port between 1-65535"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter target port ${DIM}[8443]${NC}: \c"
        read TARGET_PORT
        TARGET_PORT="${TARGET_PORT:-8443}"
    done
    print_success "Target Port: ${CYAN}${TARGET_PORT}${NC}"
    
    # Question 7: Domain for nginx
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 7:${NC} What domain name should be used for the nginx decoy site?"
    echo -e "${DIM}This is used for the fake website that hides the tunnel.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter domain name ${DIM}[test.bale.cyou]${NC}: \c"
    read DOMAIN
    DOMAIN="${DOMAIN:-test.bale.cyou}"
    print_success "Domain: ${CYAN}${DOMAIN}${NC}"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "UUID" "$UUID"
    print_config_item "Private Key" "$SERVER_B_PRIVATE_KEY"
    print_config_item "Short ID" "$SERVER_B_SHORT_ID"
    print_config_item "Server Name" "$SERVER_NAME"
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Target Port" "$TARGET_PORT"
    print_config_item "Domain" "$DOMAIN"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server B installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray and Nginx
    print_section "Installing Services"
    if ! command -v xray >/dev/null 2>&1; then
        print_info "Installing Xray..."
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
        print_success "Xray installed successfully"
    else
        print_success "Xray is already installed"
    fi
    
    if ! command -v nginx >/dev/null 2>&1; then
        print_info "Installing Nginx..."
        if command -v apt >/dev/null 2>&1; then
            apt update && apt install -y nginx
        elif command -v yum >/dev/null 2>&1; then
            yum install -y nginx
        elif command -v dnf >/dev/null 2>&1; then
            dnf install -y nginx
        fi
        print_success "Nginx installed successfully"
    else
        print_success "Nginx is already installed"
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Generate Server B configuration
    cat > /etc/xray/b.json << EOF
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "tag": "tunnel-in",
      "listen": "0.0.0.0",
      "port": $TUNNEL_PORT,
      "protocol": "vless",
      "settings": {
        "clients": [
          { "id": "$UUID" }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "www.microsoft.com:443",
          "serverNames": ["$SERVER_NAME"],
          "privateKey": "$SERVER_B_PRIVATE_KEY",
          "shortIds": ["$SERVER_B_SHORT_ID"]
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 1000000,
          "scMaxConcurrentPosts": 6,
          "scMinPostsIntervalMs": 25,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 200,
          "keepaliveperiod": 60,
          "mode": "auto"
        }
      }
    }
  ],
  "outbounds": [
    { "tag": "to-nginx-80",  "protocol": "freedom", "settings": { "redirect": "127.0.0.1:80"  } },
    { "tag": "to-nginx-443", "protocol": "freedom", "settings": { "redirect": "127.0.0.1:443" } },
    { "tag": "to-xmplus",    "protocol": "freedom", "settings": { "redirect": "127.0.0.1:$TARGET_PORT" } }
  ],
  "routing": {
    "rules": [
      { "type": "field", "inboundTag": ["tunnel-in"], "port": "80",   "outboundTag": "to-nginx-80"  },
      { "type": "field", "inboundTag": ["tunnel-in"], "port": "443",  "outboundTag": "to-nginx-443" },
      { "type": "field", "inboundTag": ["tunnel-in"], "port": "8080,$TARGET_PORT,8082,9090", "outboundTag": "to-xmplus" }
    ]
  }
}
EOF
    
    # Set permissions
    chown root:root /etc/xray/b.json
    chmod 644 /etc/xray/b.json
    print_success "Configuration file created: /etc/xray/b.json"
    print_section_end
    
    # Generate Nginx configuration
    print_section "Setting Up Nginx"
    cat > /etc/nginx/conf.d/stealth-$TUNNEL_PORT.conf << EOF
# Public HTTP -> redirect to HTTPS
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    return 301 https://\$host\$request_uri;
}

# Public HTTPS decoy site
server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;
    server_name $DOMAIN;

    ssl_certificate     /etc/ssl/certs/decoy.crt;
    ssl_certificate_key /etc/ssl/private/decoy.key;

    # Minimal "normal" site
    root /var/www/html;
    index index.html;

    # Security headers (optional but fine)
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Serve files; no tunnel proxy here
    location / {
        try_files \$uri \$uri/ =404;
    }

    # Block dotfiles & configs
    location ~ /\\.         { deny all; }
    location ~ \\.(log|conf)\$ { deny all; }
}
EOF
    
    # Create decoy SSL certificates if they don't exist
    if [ ! -f "/etc/ssl/certs/decoy.crt" ]; then
        print_info "Creating decoy SSL certificates..."
        mkdir -p /etc/ssl/certs /etc/ssl/private
        
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/ssl/private/decoy.key \
            -out /etc/ssl/certs/decoy.crt \
            -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"
        print_success "SSL certificates created"
    fi
    
    # Create web root and index
    mkdir -p /var/www/html
    cat > /var/www/html/index.html << 'HTML'
<!DOCTYPE html>
<html>
<head>
    <title>Welcome</title>
</head>
<body>
    <h1>Welcome to our website</h1>
    <p>This is a normal website.</p>
</body>
</html>
HTML
    print_success "Nginx configuration created: /etc/nginx/conf.d/stealth-$TUNNEL_PORT.conf"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Services"
    cat > /etc/systemd/system/xray-b.service << 'EOF'
[Unit]
Description=Xray Service (Server B)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/b.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Reload systemd and start services
    systemctl daemon-reload
    systemctl enable xray-b
    systemctl restart xray-b
    systemctl enable nginx
    systemctl restart nginx
    print_success "Services created and started: xray-b.service, nginx.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server B installation completed successfully!"
    echo
    print_info "Configuration files:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Xray config:${NC} /etc/xray/b.json"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Nginx config:${NC} /etc/nginx/conf.d/stealth-$TUNNEL_PORT.conf"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Logs location:${NC} /var/log/xray/"
    echo
    print_success "Tunnel is now active!"
    print_info "Traffic routing:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Ports 80,443:${NC} → nginx"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Ports 8080,$TARGET_PORT,8082,9090:${NC} → target service"
    print_section_end
}

# Function to show usage
show_usage() {
    print_header
    echo -e "${WHITE}${BOLD}Usage:${NC} bash install [server-type]"
    echo
    echo -e "${WHITE}${BOLD}Server types:${NC}"
    echo -e "  ${CYAN}a, server-a, tunnel${NC}    Install on Server A (Tunnel Server)"
    echo -e "  ${CYAN}b, server-b, dest${NC}     Install on Server B (Destination Server)"
    echo -e "  ${CYAN}auto${NC}                  Auto-detect server type (default)"
    echo
    echo -e "${WHITE}${BOLD}Examples:${NC}"
    echo -e "  ${DIM}bash install${NC}"
    echo -e "  ${DIM}bash install a${NC}"
    echo -e "  ${DIM}bash install server-b${NC}"
    echo
    echo -e "${WHITE}${BOLD}Manual installation:${NC}"
    echo -e "  ${DIM}bash install_a.sh${NC}    # For Server A only"
    echo -e "  ${DIM}bash install_b.sh${NC}    # For Server B only"
}

# Main function
main() {
    # Check for help first
    if [ $# -gt 0 ] && [[ "$1" =~ ^(--help|-h|help)$ ]]; then
        show_usage
        exit 0
    fi
    
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        print_error "Please run as root"
        exit 1
    fi
    
    print_header
    
    # Determine server type
    SERVER_TYPE=""
    if [ $# -eq 0 ]; then
        # No arguments, show menu
        show_server_menu
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Enter your choice${NC} ${DIM}[1-3]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter choice: "
        read choice
        
        case "$choice" in
            1)
                SERVER_TYPE="a"
                ;;
            2)
                SERVER_TYPE="b"
                ;;
            3)
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Invalid choice"
                exit 1
                ;;
        esac
    else
        case "$1" in
            "a"|"server-a"|"tunnel")
                SERVER_TYPE="a"
                ;;
            "b"|"server-b"|"dest"|"destination")
                SERVER_TYPE="b"
                ;;
            "auto")
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Unknown server type: $1"
                show_usage
                exit 1
                ;;
        esac
    fi
    
    print_info "Selected server type: Server $SERVER_TYPE"
    echo
    
    if [ "$SERVER_TYPE" = "a" ]; then
        install_server_a
    elif [ "$SERVER_TYPE" = "b" ]; then
        install_server_b
    else
        print_error "Could not determine server type"
        exit 1
    fi
}

# Run main function
main "$@"
