#!/bin/bash

# VLESS+REALITY Tunnel Installation Script
# Modern Interactive Installation with Beautiful UI

set -e

# Debug mode - uncomment to enable debug output
# set -x

# Modern Color Palette
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;37m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# UI Elements
BOX_TOP="â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
BOX_BOTTOM="â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
BOX_SIDE="â”‚"
ARROW="â–¶"
CHECK="âœ“"
CROSS="âœ—"
STAR="âœ¦"
DOT="â€¢"

# Function to print with modern styling
print_header() {
    echo -e "${CYAN}${BOLD}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    ðŸš€ VLESS+REALITY TUNNEL ðŸš€                â•‘"
    echo "â•‘                   Modern Installation Script                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

print_section() {
    local title="$1"
    echo -e "\n${PURPLE}${BOLD}${STAR} ${title}${NC}"
    echo -e "${PURPLE}${BOX_TOP}${NC}"
}

print_section_end() {
    echo -e "${PURPLE}${BOX_BOTTOM}${NC}"
}

print_info() {
    echo -e "${BLUE}${ARROW}${NC} ${1}"
}

print_success() {
    echo -e "${GREEN}${CHECK}${NC} ${1}"
}

print_warning() {
    echo -e "${YELLOW}${DOT}${NC} ${1}"
}

print_error() {
    echo -e "${RED}${CROSS}${NC} ${1}"
}

print_input() {
    echo -e "${CYAN}${ARROW}${NC} ${1}"
}

print_config_item() {
    local key="$1"
    local value="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC} ${CYAN}${value}${NC}"
}

print_short_ids() {
    local key="$1"
    local short_ids="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}${short_ids}${NC}"
}

# Function to show animated loading
show_loading() {
    local message="$1"
    local pid=$!
    local delay=0.1
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    
    echo -ne "${BLUE}${ARROW}${NC} ${message} "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Function to get user input with modern styling
get_input() {
    local prompt="$1"
    local default="$2"
    local value
    
    if [ -n "$default" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC} ${DIM}[${default}]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "${value:-$default}"
    else
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "$value"
    fi
}

# Function to show confirmation dialog
confirm() {
    local message="$1"
    local default="${2:-n}"
    
    if [ "$default" = "y" ]; then
        echo -e "\n${GREEN}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[Y/n]${NC}"
        echo -ne "${GREEN}${ARROW}${NC} Enter choice: "
    else
        echo -e "\n${YELLOW}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[y/N]${NC}"
        echo -ne "${YELLOW}${ARROW}${NC} Enter choice: "
    fi
    
    read -r response
    if [ "$default" = "y" ]; then
        [[ "$response" =~ ^[Nn]$ ]] && return 1 || return 0
    else
        [[ "$response" =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

# Function to generate UUID
generate_uuid() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    elif command -v python3 >/dev/null 2>&1; then
        python3 -c "import uuid; print(uuid.uuid4())"
    else
        cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "12345678-1234-1234-1234-123456789abc"
    fi
}

# Handle Nginx configuration conflicts
handle_nginx_conflicts() {
    print_info "Checking for Nginx configuration conflicts..."
    
    # Create backup directory
    BACKUP_DIR="/etc/nginx/backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$BACKUP_DIR"
    
    # Check if there are any existing default server configurations
    if [ -f /etc/nginx/sites-enabled/default ]; then
        print_warning "Found existing default Nginx site"
        print_info "Creating backup in: $BACKUP_DIR"
        cp /etc/nginx/sites-enabled/default "$BACKUP_DIR/"
        
        if confirm "Do you want to disable the existing default site to avoid conflicts?"; then
            rm -f /etc/nginx/sites-enabled/default
            print_success "Default Nginx site disabled (backup created)"
        else
            print_warning "Keeping existing default site - this may cause conflicts"
        fi
    fi
    
    # Check for other conflicting configurations
    CONFLICTING_CONFIGS=$(find /etc/nginx -name "*.conf" -exec grep -l "default_server" {} \; 2>/dev/null || true)
    if [ -n "$CONFLICTING_CONFIGS" ]; then
        print_warning "Found configurations with default_server directive:"
        echo "$CONFLICTING_CONFIGS" | while read config; do
            print_info "  - $config"
            cp "$config" "$BACKUP_DIR/" 2>/dev/null || true
        done
        print_info "Backups created in: $BACKUP_DIR"
        print_info "Our configuration will override these"
    fi
}

# Restore Nginx configuration from backup
restore_nginx_backup() {
    print_info "Available Nginx backups:"
    BACKUP_DIRS=$(find /etc/nginx -name "backup-*" -type d 2>/dev/null | sort -r)
    if [ -z "$BACKUP_DIRS" ]; then
        print_warning "No Nginx backups found"
        return 1
    fi
    
    echo "$BACKUP_DIRS" | nl
    echo
    echo -e "${CYAN}${ARROW}${NC} Enter backup number to restore ${DIM}[1]${NC}: \c"
    read BACKUP_CHOICE
    BACKUP_CHOICE="${BACKUP_CHOICE:-1}"
    
    BACKUP_DIR=$(echo "$BACKUP_DIRS" | sed -n "${BACKUP_CHOICE}p")
    if [ -z "$BACKUP_DIR" ]; then
        print_error "Invalid backup selection"
        return 1
    fi
    
    print_info "Restoring from: $BACKUP_DIR"
    if [ -d "$BACKUP_DIR" ]; then
        cp "$BACKUP_DIR"/* /etc/nginx/sites-enabled/ 2>/dev/null || true
        print_success "Nginx configuration restored from backup"
        return 0
    else
        print_error "Backup directory not found"
        return 1
    fi
}

# Check Xray version
check_xray_version() {
    if command -v xray >/dev/null 2>&1; then
        CURRENT_VERSION=$(xray version | head -1)
        print_info "Current Xray version: ${CYAN}${CURRENT_VERSION}${NC}"
        
        # Check for latest version
        if curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest >/dev/null 2>&1; then
            LATEST_VERSION=$(curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
            if [ -n "$LATEST_VERSION" ]; then
                print_info "Latest Xray version: ${CYAN}${LATEST_VERSION}${NC}"
                if echo "$CURRENT_VERSION" | grep -q "$LATEST_VERSION"; then
                    print_success "âœ… You have the latest version"
                else
                    print_warning "âš ï¸  Update available: ${LATEST_VERSION}"
                fi
            fi
        fi
    fi
}

# Install Xray offline
install_xray_offline() {
    print_info "Checking Xray installation options..."
    
    # Get latest version information
    LATEST_VERSION=""
    if curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest >/dev/null 2>&1; then
        LATEST_VERSION=$(curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
        if [ -n "$LATEST_VERSION" ]; then
            print_info "Latest Xray version available: ${CYAN}${LATEST_VERSION}${NC}"
        fi
    fi
    
    # Check if we have internet connectivity
    if curl -s --connect-timeout 5 https://github.com >/dev/null 2>&1; then
        print_info "Internet connection available"
        print_info "Installation methods:"
        print_info "  ${GREEN}1. Online Installation${NC} - Uses official Xray installer (recommended)"
        print_info "  ${YELLOW}2. Offline Installation${NC} - Downloads binary directly (for restricted networks)"
        
        if confirm "Do you want to try online installation first?"; then
            print_info "Attempting online installation..."
            if bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install; then
                print_success "Xray installed successfully via online method"
                if [ -n "$LATEST_VERSION" ]; then
                    print_info "Installed version: ${CYAN}$(xray version | head -1)${NC}"
                fi
                return 0
            else
                print_warning "Online installation failed, trying offline method..."
            fi
        else
            print_info "Skipping online installation, using offline method..."
        fi
    else
        print_warning "No internet connection detected, using offline method..."
    fi
    
    # Offline installation method
    print_info "Installing Xray offline..."
    
    # Detect system architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="64" ;;
        aarch64|arm64) ARCH="arm64-v8a" ;;
        armv7l) ARCH="arm32-v7a" ;;
        *) print_error "Unsupported architecture: $ARCH"; return 1 ;;
    esac
    print_info "Detected architecture: ${CYAN}${ARCH}${NC}"
    
    # Use latest version if available, otherwise fallback to stable
    if [ -n "$LATEST_VERSION" ]; then
        XRAY_VERSION="$LATEST_VERSION"
        print_info "Using latest version: ${CYAN}${XRAY_VERSION}${NC}"
    else
        XRAY_VERSION="v1.8.18"
        print_warning "Using fallback version: ${CYAN}${XRAY_VERSION}${NC}"
    fi
    
    # Create temporary directory
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # Download Xray binary (try multiple mirrors)
    DOWNLOAD_URLS=(
        "https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://mirror.ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://download.fastgit.org/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
    )
    
    for url in "${DOWNLOAD_URLS[@]}"; do
        print_info "Trying to download from: $url"
        if wget -q --timeout=10 "$url" -O xray.zip || curl -L --connect-timeout 10 "$url" -o xray.zip; then
            print_success "Downloaded Xray binary successfully"
            break
        else
            print_warning "Failed to download from: $url"
        fi
    done
    
    if [ ! -f "xray.zip" ]; then
        print_error "Failed to download Xray binary from all mirrors"
        print_info "Please download Xray manually:"
        print_info "1. Go to: https://github.com/XTLS/Xray-core/releases"
        print_info "2. Download Xray-linux-${ARCH}.zip"
        print_info "3. Extract and place xray binary in /usr/local/bin/"
        print_info "4. Run: chmod +x /usr/local/bin/xray"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Extract and install
    if command -v unzip >/dev/null 2>&1; then
        unzip -q xray.zip
    else
        print_error "unzip command not found. Please install unzip first."
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Install binary
    if [ -f "xray" ]; then
        cp xray /usr/local/bin/
        chmod +x /usr/local/bin/xray
        
        # Create systemd service
        cat > /etc/systemd/system/xray.service << 'EOF'
[Unit]
Description=Xray Service
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/config.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
        
        # Create directories
        mkdir -p /etc/xray /var/log/xray
        chown nobody:nogroup /var/log/xray
        
        # Enable service
        systemctl daemon-reload
        systemctl enable xray
        
        print_success "Xray installed successfully via offline method"
        INSTALLED_VERSION=$(/usr/local/bin/xray version | head -1)
        print_info "Installed version: ${CYAN}${INSTALLED_VERSION}${NC}"
        if [ -n "$LATEST_VERSION" ] && [ "$XRAY_VERSION" = "$LATEST_VERSION" ]; then
            print_success "âœ… Latest version installed successfully"
        fi
        
        cd /
        rm -rf "$TEMP_DIR"
        return 0
    else
        print_error "Xray binary not found in downloaded archive"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
}

# Function to generate Reality keys
generate_reality_keys() {
    if command -v xray >/dev/null 2>&1; then
        KEYS=$(xray x25519 2>/dev/null)
        PUBLIC_KEY=$(echo "$KEYS" | grep "Public key:" | cut -d' ' -f3)
        PRIVATE_KEY=$(echo "$KEYS" | grep "Private key:" | cut -d' ' -f3)
        
        # Generate 20 different short IDs
        SHORT_IDS=""
        for i in {1..20}; do
            SHORT_ID=$(openssl rand -hex 8 2>/dev/null)
            if [ $i -eq 1 ]; then
                SHORT_IDS="\"$SHORT_ID\""
            else
                SHORT_IDS="$SHORT_IDS, \"$SHORT_ID\""
            fi
        done
        
        # Debug: Check if keys were parsed correctly
        if [ -z "$PUBLIC_KEY" ] || [ -z "$PRIVATE_KEY" ]; then
            print_warning "Failed to parse Reality keys, using default keys"
            PUBLIC_KEY="wwgbwD3pK6aBzxtMzAyAdzV8430zraDqrCrH7tivDV4"
            PRIVATE_KEY="kEHlrW7KE0TxG_UhhOwE2YzMbzGlWign5rSrcweFVkY"
            SHORT_IDS="\"db78ea236c7e33f5\", \"a1b2c3d4e5f67890\", \"1234567890abcdef\", \"fedcba0987654321\", \"1111222233334444\", \"5555666677778888\", \"9999aaaabbbbcccc\", \"ddddeeeeffff0000\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\", \"02468ace13579bdf\", \"fdb97531eca86420\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\""
        else
            print_success "Generated Reality keys successfully"
        fi
        
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short IDs (20):${NC} ${CYAN}Generated 20 different short IDs${NC}"
    else
        print_warning "Xray not found, using default keys"
        PUBLIC_KEY="wwgbwD3pK6aBzxtMzAyAdzV8430zraDqrCrH7tivDV4"
        PRIVATE_KEY="kEHlrW7KE0TxG_UhhOwE2YzMbzGlWign5rSrcweFVkY"
        SHORT_IDS="\"db78ea236c7e33f5\", \"a1b2c3d4e5f67890\", \"1234567890abcdef\", \"fedcba0987654321\", \"1111222233334444\", \"5555666677778888\", \"9999aaaabbbbcccc\", \"ddddeeeeffff0000\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\", \"02468ace13579bdf\", \"fdb97531eca86420\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\""
        
        print_success "Using default Reality keys"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short IDs (20):${NC} ${CYAN}Using 20 default short IDs${NC}"
    fi
    
    # Export the variables so they're available globally
    export PUBLIC_KEY
    export PRIVATE_KEY
    export SHORT_IDS
}

# Function to validate port
validate_port() {
    local port="$1"
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        return 1
    fi
    return 0
}

# Function to validate IP
validate_ip() {
    local ip="$1"
    # More comprehensive IP validation
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Check each octet is between 0-255
        IFS='.' read -ra ADDR <<< "$ip"
        for i in "${ADDR[@]}"; do
            if [[ $i -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# Function to show server selection menu
show_server_menu() {
    print_section "Server Type Selection"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Choose your server type:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}Server A (Tunnel Server)${NC} ${DIM}- Receives traffic and forwards to Server B${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}Server B (Destination Server)${NC} ${DIM}- Receives tunneled traffic and routes to services${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}Auto-detect${NC} ${DIM}- Automatically detect server type${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    print_section_end
}

# Function to detect server type
detect_server_type() {
    print_info "Auto-detecting server type..." >&2
    
    if command -v nginx >/dev/null 2>&1; then
        echo "b"
    else
        echo "a"
    fi
}

# Function to configure BBR and TCP optimizations
configure_bbr_and_tcp() {
    print_info "Configuring BBR and TCP buffer optimizations..."
    
    # Check if BBR is already enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR is already enabled"
        else
            print_info "Enabling BBR..."
        fi
    fi
    
    # Create comprehensive sysctl configuration
    cat > /etc/sysctl.d/99-xray-optimization.conf << 'EOF'
# BBR Congestion Control
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr

# TCP Buffer Optimizations for High Bandwidth
net.core.rmem_max=134217728
net.core.wmem_max=134217728
net.ipv4.tcp_rmem=4096 87380 67108864
net.ipv4.tcp_wmem=4096 65536 67108864
net.ipv4.tcp_mem=262144 524288 1048576

# TCP Window Scaling
net.ipv4.tcp_window_scaling=1
net.ipv4.tcp_timestamps=1
net.ipv4.tcp_sack=1

# TCP Fast Open
net.ipv4.tcp_fastopen=3

# Connection Tracking
net.netfilter.nf_conntrack_max=1000000
net.ipv4.netfilter.ip_conntrack_max=1000000

# Socket Options
net.core.somaxconn=65535
net.core.netdev_max_backlog=5000

# TCP Keepalive
net.ipv4.tcp_keepalive_time=600
net.ipv4.tcp_keepalive_probes=3
net.ipv4.tcp_keepalive_intvl=15

# TCP SYN Cookies (DDoS protection)
net.ipv4.tcp_syncookies=1

# TCP Fin Timeout
net.ipv4.tcp_fin_timeout=30

# TCP Tw Reuse
net.ipv4.tcp_tw_reuse=1

# IP Forwarding (if needed)
# net.ipv4.ip_forward=1
EOF
    
    # Apply sysctl settings
    sysctl --system >/dev/null 2>&1
    
    # Verify BBR is enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR enabled successfully"
        else
            print_warning "BBR may require kernel module. Current: $CURRENT_CC"
            print_info "To enable BBR manually, run: modprobe tcp_bbr"
        fi
    fi
    
    print_success "TCP buffer optimizations configured"
    print_info "Optimizations applied:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}BBR:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}TCP Buffers:${NC} Optimized for high bandwidth"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Window Scaling:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Fast Open:${NC} Enabled"
}

# Function to configure BBR and TCP optimizations
configure_bbr_and_tcp() {
    print_info "Configuring BBR and TCP buffer optimizations..."
    
    # Check if BBR is already enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR is already enabled"
        else
            print_info "Enabling BBR..."
        fi
    fi
    
    # Create comprehensive sysctl configuration
    cat > /etc/sysctl.d/99-xray-optimization.conf << 'EOF'
# BBR Congestion Control
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr

# TCP Buffer Optimizations for High Bandwidth
net.core.rmem_max=134217728
net.core.wmem_max=134217728
net.ipv4.tcp_rmem=4096 87380 67108864
net.ipv4.tcp_wmem=4096 65536 67108864
net.ipv4.tcp_mem=262144 524288 1048576

# TCP Window Scaling
net.ipv4.tcp_window_scaling=1
net.ipv4.tcp_timestamps=1
net.ipv4.tcp_sack=1

# TCP Fast Open
net.ipv4.tcp_fastopen=3

# Connection Tracking
net.netfilter.nf_conntrack_max=1000000
net.ipv4.netfilter.ip_conntrack_max=1000000

# Socket Options
net.core.somaxconn=65535
net.core.netdev_max_backlog=5000

# TCP Keepalive
net.ipv4.tcp_keepalive_time=600
net.ipv4.tcp_keepalive_probes=3
net.ipv4.tcp_keepalive_intvl=15

# TCP SYN Cookies (DDoS protection)
net.ipv4.tcp_syncookies=1

# TCP Fin Timeout
net.ipv4.tcp_fin_timeout=30

# TCP Tw Reuse
net.ipv4.tcp_tw_reuse=1

# IP Forwarding (if needed)
# net.ipv4.ip_forward=1
EOF
    
    # Apply sysctl settings
    sysctl --system >/dev/null 2>&1
    
    # Verify BBR is enabled
    if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
        CURRENT_CC=$(cat /proc/sys/net/ipv4/tcp_congestion_control)
        if [ "$CURRENT_CC" = "bbr" ]; then
            print_success "BBR enabled successfully"
        else
            print_warning "BBR may require kernel module. Current: $CURRENT_CC"
            print_info "To enable BBR manually, run: modprobe tcp_bbr"
        fi
    fi
    
    print_success "TCP buffer optimizations configured"
    print_info "Optimizations applied:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}BBR:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}TCP Buffers:${NC} Optimized for high bandwidth"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Window Scaling:${NC} Enabled"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Fast Open:${NC} Enabled"
}

# Function to install Server A
install_server_a() {
    print_section "Server A Configuration"
    
    # Get configuration from user
    print_info "I will ask you for each configuration detail one by one."
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: Server B IP
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the IP address of Server B (destination server)?"
    echo -e "${DIM}This is the server where your tunneled traffic will be sent.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
    read SERVER_B_IP
    
    while [ -z "$SERVER_B_IP" ] || ! validate_ip "$SERVER_B_IP"; do
        if [ -z "$SERVER_B_IP" ]; then
            print_error "Server B IP address is required. Please enter a valid IP address."
        else
            print_error "Invalid IP address format. Please enter a valid IP like 192.168.1.100"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
        read SERVER_B_IP
    done
    print_success "Server B IP: ${CYAN}${SERVER_B_IP}${NC}"
    
    # Question 2: Tunnel Port
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What port should be used for the VLESS tunnel connection?"
    echo -e "${DIM}This is the port that Server A will connect to on Server B.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        print_error "Invalid port number. Please enter a port between 1-65535"
        echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Question 3: Transport Protocol Selection
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} Which transport protocol do you want to use?"
    echo -e "${DIM}Select the transport protocol for the tunnel connection.${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}XHTTP (SplitHTTP)${NC} ${DIM}- Stealth HTTP-based transport (recommended)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}TCP Raw${NC} ${DIM}- Direct TCP connection (fastest, no encryption)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}WebSocket${NC} ${DIM}- WebSocket transport (good for CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}4.${NC} ${WHITE}GRPC${NC} ${DIM}- gRPC transport (good for CDN)${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter choice ${DIM}[1-4, default: 1]${NC}: \c"
    read TRANSPORT_CHOICE
    TRANSPORT_CHOICE="${TRANSPORT_CHOICE:-1}"
    
    case $TRANSPORT_CHOICE in
        1)
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=true
            ;;
        2)
            TRANSPORT_PROTOCOL="tcp"
            USE_REALITY=false
            ;;
        3)
            TRANSPORT_PROTOCOL="ws"
            USE_REALITY=false
            ;;
        4)
            TRANSPORT_PROTOCOL="grpc"
            USE_REALITY=false
            ;;
        *)
            print_warning "Invalid choice, using XHTTP (SplitHTTP)"
            TRANSPORT_PROTOCOL="splithttp"
            USE_REALITY=true
            ;;
    esac
    print_success "Transport Protocol: ${CYAN}${TRANSPORT_PROTOCOL}${NC}"
    
    # Question 4: Client Ports (ports that Server A will listen on)
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} Which ports should Server A listen on for client connections?"
    echo -e "${DIM}Enter ports separated by commas (e.g., 80,443,8080,8443).${NC}"
    echo -e "${DIM}These are the ports that clients will connect to on Server A.${NC}"
    echo -e "${DIM}Traffic on these ports will be forwarded through the tunnel to Server B.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter client ports ${DIM}[80,443,8080,8443]${NC}: \c"
    read CLIENT_PORTS_INPUT
    CLIENT_PORTS_INPUT="${CLIENT_PORTS_INPUT:-80,443,8080,8443}"
    
    # Validate all ports
    IFS=',' read -ra PORT_ARRAY <<< "$CLIENT_PORTS_INPUT"
    VALID_PORTS=""
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if validate_port "$port"; then
            if [ -z "$VALID_PORTS" ]; then
                VALID_PORTS="$port"
            else
                VALID_PORTS="$VALID_PORTS,$port"
            fi
        else
            print_error "Invalid port: $port (skipping)"
        fi
    done
    
    if [ -z "$VALID_PORTS" ]; then
        print_error "No valid ports provided. Using defaults: 80,443,8080,8443"
        CLIENT_PORTS="80,443,8080,8443"
    else
        CLIENT_PORTS="$VALID_PORTS"
    fi
    print_success "Client Ports: ${CYAN}${CLIENT_PORTS}${NC}"
    
    # Question 5: Path (for WebSocket/GRPC) or Server Name (for Reality)
    if [ "$USE_REALITY" = true ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What server name should be used for Reality protocol (SNI)?"
        echo -e "${DIM}This is used to disguise the connection as legitimate traffic.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Reality server name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
        read SERVER_NAME
        SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
        print_success "Reality Server Name: ${CYAN}${SERVER_NAME}${NC}"
        TRANSPORT_PATH="/assets"
    else
        if [ "$TRANSPORT_PROTOCOL" = "ws" ] || [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
            echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What path should be used for ${TRANSPORT_PROTOCOL}?"
            echo -e "${DIM}This is the HTTP path for WebSocket/GRPC connections.${NC}"
            if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
                echo -e "${CYAN}${ARROW}${NC} Enter WebSocket path ${DIM}[/assets]${NC}: \c"
            else
                echo -e "${CYAN}${ARROW}${NC} Enter GRPC service name ${DIM}[/xray.XrayService]${NC}: \c"
            fi
            read TRANSPORT_PATH
            if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
                TRANSPORT_PATH="${TRANSPORT_PATH:-/assets}"
            else
                TRANSPORT_PATH="${TRANSPORT_PATH:-/xray.XrayService}"
            fi
            print_success "Path: ${CYAN}${TRANSPORT_PATH}${NC}"
        else
            TRANSPORT_PATH=""
        fi
        SERVER_NAME=""
    fi
    
    # Generate keys only if using Reality
    if [ "$USE_REALITY" = true ]; then
        generate_reality_keys
    else
        PUBLIC_KEY=""
        PRIVATE_KEY=""
        SHORT_IDS=""
    fi
    
    # Generate UUID
    UUID=$(generate_uuid)
    print_success "Generated UUID: ${CYAN}${UUID}${NC}"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "Server B IP" "$SERVER_B_IP"
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Client Ports" "$CLIENT_PORTS"
    print_config_item "Transport Protocol" "$TRANSPORT_PROTOCOL"
    if [ -n "$TRANSPORT_PATH" ]; then
        print_config_item "Transport Path" "$TRANSPORT_PATH"
    fi
    if [ "$USE_REALITY" = true ]; then
        print_config_item "Server Name" "$SERVER_NAME"
        print_config_item "Public Key (for Server A)" "$PUBLIC_KEY"
        print_config_item "Private Key (for Server B)" "$PRIVATE_KEY"
        print_short_ids "Short IDs (20 different)" "$SHORT_IDS"
    fi
    print_config_item "UUID" "$UUID"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server A installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray
    print_section "Installing Xray"
    if ! command -v xray >/dev/null 2>&1; then
        install_xray_offline
    else
        print_success "Xray is already installed"
        check_xray_version
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Generate Server A configuration
    TEMP_CONFIG_A=$(mktemp)
    
    # Build base config
    cat > "$TEMP_CONFIG_A" << 'BASEEOF'
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
INBOUNDS_PLACEHOLDER
  ],
  "outbounds": [
    {
      "tag": "to-b",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "SERVER_B_IP_PLACEHOLDER",
            "port": TUNNEL_PORT_PLACEHOLDER,
            "users": [
              { "id": "UUID_PLACEHOLDER", "encryption": "none" }
            ]
          }
        ]
      },
      "streamSettings": {
STREAM_SETTINGS_PLACEHOLDER
      }
    },
    { "protocol": "freedom", "tag": "direct" }
  ],
  "routing": {
    "domainStrategy": "AsIs",
    "rules": [
ROUTING_RULES_PLACEHOLDER
    ]
  }
}
BASEEOF
    
    # Build inbounds dynamically based on CLIENT_PORTS
    INBOUNDS_JSON=""
    IFS=',' read -ra PORT_ARRAY <<< "$CLIENT_PORTS"
    FIRST_INBOUND=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_INBOUND" = true ]; then
            FIRST_INBOUND=false
        else
            INBOUNDS_JSON="$INBOUNDS_JSON,"
        fi
        INBOUNDS_JSON="${INBOUNDS_JSON}
    {
      \"tag\": \"entry-${port}\",
      \"listen\": \"0.0.0.0\",
      \"port\": ${port},
      \"protocol\": \"dokodemo-door\",
      \"settings\": { \"address\": \"127.0.0.1\", \"port\": ${port}, \"network\": \"tcp\" }
    }"
    done
    
    # Build routing rules dynamically
    ROUTING_RULES_JSON=""
    FIRST_RULE=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_RULE" = true ]; then
            FIRST_RULE=false
        else
            ROUTING_RULES_JSON="$ROUTING_RULES_JSON,"
        fi
        ROUTING_RULES_JSON="${ROUTING_RULES_JSON}
      { \"type\": \"field\", \"inboundTag\": [\"entry-${port}\"], \"outboundTag\": \"to-b\" }"
    done
    
    # Replace placeholders
    sed -i "s|INBOUNDS_PLACEHOLDER|$INBOUNDS_JSON|g" "$TEMP_CONFIG_A"
    sed -i "s|ROUTING_RULES_PLACEHOLDER|$ROUTING_RULES_JSON|g" "$TEMP_CONFIG_A"
    
    # Build streamSettings based on transport protocol
    STREAM_SETTINGS_TEMP=$(mktemp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "serverName": "$SERVER_NAME",
          "publicKey": "$PUBLIC_KEY",
          "shortIds": [$SHORT_IDS],
          "fingerprint": "chrome",
          "spiderX": "/"
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 2097152,
          "scMaxConcurrentPosts": 4,
          "scMinPostsIntervalMs": 50,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 0,
          "keepaliveperiod": 120,
          "mode": "Paket-up"
        }
EOF
    elif [ "$TRANSPORT_PROTOCOL" = "tcp" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "tcp"
EOF
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "ws",
        "wsSettings": {
          "path": "$TRANSPORT_PATH"
        }
EOF
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "grpc",
        "grpcSettings": {
          "serviceName": "$TRANSPORT_PATH"
        }
EOF
    fi
    
    # Replace placeholders
    sed -i "s/SERVER_B_IP_PLACEHOLDER/$SERVER_B_IP/g" "$TEMP_CONFIG_A"
    sed -i "s/TUNNEL_PORT_PLACEHOLDER/$TUNNEL_PORT/g" "$TEMP_CONFIG_A"
    sed -i "s/UUID_PLACEHOLDER/$UUID/g" "$TEMP_CONFIG_A"
    
    # Replace streamSettings placeholder with actual settings
    STREAM_SETTINGS_CONTENT=$(cat "$STREAM_SETTINGS_TEMP" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
    sed -i "s|STREAM_SETTINGS_PLACEHOLDER|$(cat "$STREAM_SETTINGS_TEMP")|g" "$TEMP_CONFIG_A"
    
    # Move to final location
    mv "$TEMP_CONFIG_A" /etc/xray/a.json
    rm -f "$STREAM_SETTINGS_TEMP"
    
    # Set permissions
    chown root:root /etc/xray/a.json
    chmod 644 /etc/xray/a.json
    print_success "Configuration file created: /etc/xray/a.json"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Service"
    cat > /etc/systemd/system/xray-a.service << 'EOF'
[Unit]
Description=Xray Service (Server A)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/a.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Configure firewall for client ports
    print_section "Configuring Firewall"
    print_info "Configuring firewall for client ports..."
    if command -v ufw >/dev/null 2>&1; then
        ufw allow 22/tcp
        IFS=',' read -ra PORT_ARRAY <<< "$CLIENT_PORTS"
        for port in "${PORT_ARRAY[@]}"; do
            port=$(echo "$port" | xargs) # trim whitespace
            ufw allow "$port/tcp"
        done
        print_success "Firewall configured for client ports: $CLIENT_PORTS"
    else
        print_warning "UFW not found. Please configure firewall manually for ports: $CLIENT_PORTS"
    fi
    print_section_end
    
    # Configure BBR and TCP optimizations
    print_section "Configuring Network Optimizations"
    configure_bbr_and_tcp
    print_section_end
    
    # Reload systemd and start service
    systemctl daemon-reload
    systemctl enable xray-a
    systemctl restart xray-a
    print_success "Service created and started: xray-a.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server A installation completed successfully!"
    echo
    print_info "Configuration saved to: /etc/xray/a.json"
    print_info "Service: xray-a.service"
    print_info "Logs location: /var/log/xray/"
    echo
    print_warning "IMPORTANT: Save these details for Server B installation:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}UUID:${NC} ${CYAN}${UUID}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Transport Protocol:${NC} ${CYAN}${TRANSPORT_PROTOCOL}${NC}"
    if [ -n "$TRANSPORT_PATH" ]; then
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Transport Path:${NC} ${CYAN}${TRANSPORT_PATH}${NC}"
    fi
    if [ "$USE_REALITY" = true ]; then
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key (for Server B):${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short IDs (20 different):${NC} ${CYAN}${SHORT_IDS}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Server Name:${NC} ${CYAN}${SERVER_NAME}${NC}"
    fi
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Tunnel Port:${NC} ${CYAN}${TUNNEL_PORT}${NC}"
    echo
    if [ "$USE_REALITY" = true ]; then
        print_info "Note: Public Key is already configured in Server A, Private Key goes to Server B"
    fi
    print_section_end
}

# Function to install Server B
install_server_b() {
    print_section "Server B Configuration"
    
    print_info "I will ask you for each configuration detail one by one."
    echo
    print_warning "You need the details from Server A installation first!"
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: UUID from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the UUID from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter UUID: \c"
    read UUID
    if [ -z "$UUID" ]; then
        print_error "UUID is required. Please enter the UUID from Server A."
        exit 1
    fi
    print_success "UUID: ${CYAN}${UUID}${NC}"
    
    # Question 2: Transport Protocol from Server A (must be asked first!)
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What transport protocol was used on Server A?"
    echo -e "${DIM}This should match the transport protocol selected on Server A.${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}XHTTP (SplitHTTP)${NC} ${DIM}- With Reality (recommended for stealth)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}TCP Raw${NC} ${DIM}- Without TLS (fastest)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}WebSocket${NC} ${DIM}- Without TLS (suitable for CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}4.${NC} ${WHITE}GRPC${NC} ${DIM}- Without TLS (suitable for CDN)${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter choice ${DIM}[1-4, default: 1]${NC}: \c"
    read TRANSPORT_CHOICE
    TRANSPORT_CHOICE="${TRANSPORT_CHOICE:-1}"
    
    case $TRANSPORT_CHOICE in
        1)
            TRANSPORT_PROTOCOL="splithttp"
            ;;
        2)
            TRANSPORT_PROTOCOL="tcp"
            ;;
        3)
            TRANSPORT_PROTOCOL="ws"
            ;;
        4)
            TRANSPORT_PROTOCOL="grpc"
            ;;
        *)
            print_warning "Invalid choice, using XHTTP (SplitHTTP)"
            TRANSPORT_PROTOCOL="splithttp"
            ;;
    esac
    print_success "Transport Protocol: ${CYAN}${TRANSPORT_PROTOCOL}${NC}"
    
    # Question 3: Private Key (only if using Reality/splithttp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} What is the Private Key from Server A installation?"
        echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Private Key: \c"
        read SERVER_B_PRIVATE_KEY
        if [ -z "$SERVER_B_PRIVATE_KEY" ]; then
            print_error "Private Key is required. Please enter the Private Key from Server A."
            exit 1
        fi
        print_success "Private Key: ${CYAN}${SERVER_B_PRIVATE_KEY}${NC}"
    else
        SERVER_B_PRIVATE_KEY=""
    fi
    
    # Question 4: Path (if WebSocket or GRPC)
    if [ "$TRANSPORT_PROTOCOL" = "ws" ] || [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} What path/service name was used on Server A?"
        if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
            echo -e "${DIM}This is the WebSocket path used on Server A.${NC}"
            echo -e "${CYAN}${ARROW}${NC} Enter WebSocket path ${DIM}[/assets]${NC}: \c"
        else
            echo -e "${DIM}This is the GRPC service name used on Server A.${NC}"
            echo -e "${CYAN}${ARROW}${NC} Enter GRPC service name ${DIM}[/xray.XrayService]${NC}: \c"
        fi
        read TRANSPORT_PATH
        if [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
            TRANSPORT_PATH="${TRANSPORT_PATH:-/assets}"
        else
            TRANSPORT_PATH="${TRANSPORT_PATH:-/xray.XrayService}"
        fi
        print_success "Path: ${CYAN}${TRANSPORT_PATH}${NC}"
    else
        TRANSPORT_PATH=""
    fi
    
    # Question 5: Short IDs (only if using Reality/splithttp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What are the Short IDs from Server A installation?"
        echo -e "${DIM}This was generated and shown to you during Server A setup (20 different short IDs).${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Short IDs (comma-separated): \c"
        read SERVER_B_SHORT_IDS
        if [ -z "$SERVER_B_SHORT_IDS" ]; then
            print_error "Short IDs are required. Please enter the Short IDs from Server A."
            exit 1
        fi
        print_success "Short IDs: ${CYAN}${SERVER_B_SHORT_IDS}${NC}"
    else
        SERVER_B_SHORT_IDS=""
    fi
    
    # Question 5/6: Server Name (only if using Reality/splithttp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 6:${NC} What is the Server Name from Server A installation?"
        echo -e "${DIM}This is the Reality server name (SNI) you used on Server A.${NC}"
        echo -e "${CYAN}${ARROW}${NC} Enter Server Name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
        read SERVER_NAME
        SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
        print_success "Server Name: ${CYAN}${SERVER_NAME}${NC}"
    else
        SERVER_NAME=""
    fi
    
    # Tunnel Port from Server A (question number depends on transport protocol)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        QUESTION_NUM="7"
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ] || [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        QUESTION_NUM="5"
    else
        QUESTION_NUM="3"
    fi
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What is the Tunnel Port from Server A installation?"
    echo -e "${DIM}This is the port you used for VLESS connection on Server A.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        print_error "Invalid port number. Please enter a port between 1-65535"
        echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Ports to forward (question number depends on transport protocol)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        QUESTION_NUM="8"
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ] || [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        QUESTION_NUM="6"
    else
        QUESTION_NUM="4"
    fi
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question ${QUESTION_NUM}:${NC} What ports should Server B forward traffic to?"
    echo -e "${DIM}Enter ports separated by commas (e.g., 80,8080,8443).${NC}"
    echo -e "${DIM}Traffic from Server A on port 80 will be forwarded to 127.0.0.1:80${NC}"
    echo -e "${DIM}Traffic from Server A on port 8080 will be forwarded to 127.0.0.1:8080${NC}"
    echo -e "${DIM}Ports are preserved - same port in = same port out${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter ports ${DIM}[80,8080,8443]${NC}: \c"
    read ASSIGNED_PORTS
    ASSIGNED_PORTS="${ASSIGNED_PORTS:-80,8080,8443}"
    
    # Validate all ports
    IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
    VALID_PORTS=""
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if validate_port "$port"; then
            if [ -z "$VALID_PORTS" ]; then
                VALID_PORTS="$port"
            else
                VALID_PORTS="$VALID_PORTS,$port"
            fi
        else
            print_error "Invalid port: $port"
        fi
    done
    
    if [ -z "$VALID_PORTS" ]; then
        print_error "No valid ports provided. Using defaults: 80,8080,8443"
        ASSIGNED_PORTS="80,8080,8443"
    else
        ASSIGNED_PORTS="$VALID_PORTS"
    fi
    print_success "Ports to forward: ${CYAN}${ASSIGNED_PORTS}${NC}"
    print_info "Traffic will be forwarded to 127.0.0.1:<same-port>"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "UUID" "$UUID"
    print_config_item "Transport Protocol" "$TRANSPORT_PROTOCOL"
    if [ -n "$TRANSPORT_PATH" ]; then
        print_config_item "Transport Path" "$TRANSPORT_PATH"
    fi
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        print_config_item "Private Key" "$SERVER_B_PRIVATE_KEY"
        print_short_ids "Short IDs (20 different)" "$SERVER_B_SHORT_IDS"
        print_config_item "Server Name" "$SERVER_NAME"
    fi
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Ports to Forward" "$ASSIGNED_PORTS"
    print_info "Port routing: Each port forwards to 127.0.0.1:<same-port>"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server B installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray only (no nginx)
    print_section "Installing Services"
    if ! command -v xray >/dev/null 2>&1; then
        install_xray_offline
    else
        print_success "Xray is already installed"
        check_xray_version
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Generate Server B configuration with port-preserving routing
    TEMP_CONFIG=$(mktemp)
    
    # Start with base config
    cat > "$TEMP_CONFIG" << 'BASEEOF'
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "tag": "tunnel-in",
      "listen": "0.0.0.0",
      "port": TUNNEL_PORT_PLACEHOLDER,
      "protocol": "vless",
      "settings": {
        "clients": [
          { "id": "UUID_PLACEHOLDER" }
        ],
        "decryption": "none"
      },
      "streamSettings": {
STREAM_SETTINGS_PLACEHOLDER
      }
    }
  ],
  "outbounds": [
BASEEOF
    
    # Create outbounds for each port (port-preserving)
    IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
    FIRST_OUTBOUND=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_OUTBOUND" = true ]; then
            FIRST_OUTBOUND=false
        else
            echo "," >> "$TEMP_CONFIG"
        fi
        cat >> "$TEMP_CONFIG" << OUTBOUNDEOF
    { "tag": "to-port-$port", "protocol": "freedom", "settings": { "redirect": "127.0.0.1:$port" } }
OUTBOUNDEOF
    done
    
    # Add routing rules
    cat >> "$TEMP_CONFIG" << ROUTINGEOF
  ],
  "routing": {
    "rules": [
ROUTINGEOF
    
    # Add routing rules for each port (port-preserving)
    FIRST_RULE=true
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        if [ "$FIRST_RULE" = true ]; then
            FIRST_RULE=false
        else
            echo "," >> "$TEMP_CONFIG"
        fi
        cat >> "$TEMP_CONFIG" << RULEEOF
      { "type": "field", "inboundTag": ["tunnel-in"], "port": $port, "outboundTag": "to-port-$port" }
RULEEOF
    done
    
    cat >> "$TEMP_CONFIG" << ENDEOF
    ]
  }
}
ENDEOF
    
    # Build streamSettings based on transport protocol
    STREAM_SETTINGS_TEMP=$(mktemp)
    if [ "$TRANSPORT_PROTOCOL" = "splithttp" ]; then
        # Format short IDs properly
        FORMATTED_SHORT_IDS=$(echo "$SERVER_B_SHORT_IDS" | sed 's/"//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/[[:space:]]*,[[:space:]]*/,/g' | sed 's/,/\n/g' | sed 's/^/"/;s/$/"/' | tr '\n' ',' | sed 's/,$//')
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "www.microsoft.com:443",
          "serverNames": ["$SERVER_NAME"],
          "privateKey": "$SERVER_B_PRIVATE_KEY",
          "shortIds": [$FORMATTED_SHORT_IDS]
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 2097152,
          "scMaxConcurrentPosts": 4,
          "scMinPostsIntervalMs": 50,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 0,
          "keepaliveperiod": 120,
          "mode": "Paket-up"
        }
EOF
    elif [ "$TRANSPORT_PROTOCOL" = "tcp" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "tcp"
EOF
    elif [ "$TRANSPORT_PROTOCOL" = "ws" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "ws",
        "wsSettings": {
          "path": "$TRANSPORT_PATH"
        }
EOF
    elif [ "$TRANSPORT_PROTOCOL" = "grpc" ]; then
        cat > "$STREAM_SETTINGS_TEMP" << EOF
        "network": "grpc",
        "grpcSettings": {
          "serviceName": "$TRANSPORT_PATH"
        }
EOF
    fi
    
    # Replace streamSettings placeholder
    sed -i "/STREAM_SETTINGS_PLACEHOLDER/r $STREAM_SETTINGS_TEMP" "$TEMP_CONFIG"
    sed -i "/STREAM_SETTINGS_PLACEHOLDER/d" "$TEMP_CONFIG"
    
    # Replace other placeholders
    sed -i "s/TUNNEL_PORT_PLACEHOLDER/$TUNNEL_PORT/g" "$TEMP_CONFIG"
    sed -i "s/UUID_PLACEHOLDER/$UUID/g" "$TEMP_CONFIG"
    
    # Cleanup
    rm -f "$STREAM_SETTINGS_TEMP"
    
    # Move temp config to final location
    mv "$TEMP_CONFIG" /etc/xray/b.json
    
    # Set permissions
    chown root:root /etc/xray/b.json
    chmod 644 /etc/xray/b.json
    print_success "Configuration file created: /etc/xray/b.json"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Services"
    cat > /etc/systemd/system/xray-b.service << 'EOF'
[Unit]
Description=Xray Service (Server B)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/b.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Configure firewall for assigned ports
    print_info "Configuring firewall..."
    if command -v ufw >/dev/null 2>&1; then
        ufw allow 22/tcp
        ufw allow "$TUNNEL_PORT/tcp"
        IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
        for port in "${PORT_ARRAY[@]}"; do
            port=$(echo "$port" | xargs) # trim whitespace
            ufw allow "$port/tcp"
        done
        print_success "Firewall configured"
    else
        print_warning "UFW not found. Please configure firewall manually for ports: $ASSIGNED_PORTS"
    fi
    
    # Reload systemd and start service
    systemctl daemon-reload
    systemctl enable xray-b
    systemctl restart xray-b
    print_success "Service created and started: xray-b.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server B installation completed successfully!"
    echo
    print_info "Configuration files:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Xray config:${NC} /etc/xray/b.json"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Logs location:${NC} /var/log/xray/"
    echo
    print_success "Tunnel is now active!"
    print_info "Traffic routing (port-preserving):"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Tunnel Port ($TUNNEL_PORT):${NC} â†’ Receives tunneled traffic from Server A"
    IFS=',' read -ra PORT_ARRAY <<< "$ASSIGNED_PORTS"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Port $port:${NC} â†’ 127.0.0.1:$port"
    done
    print_section_end
}

# Function to show usage
show_usage() {
    print_header
    echo -e "${WHITE}${BOLD}Usage:${NC} bash install [server-type]"
    echo
    echo -e "${WHITE}${BOLD}Server types:${NC}"
    echo -e "  ${CYAN}a, server-a, tunnel${NC}    Install on Server A (Tunnel Server)"
    echo -e "  ${CYAN}b, server-b, dest${NC}     Install on Server B (Destination Server)"
    echo -e "  ${CYAN}auto${NC}                  Auto-detect server type (default)"
    echo
    echo -e "${WHITE}${BOLD}Examples:${NC}"
    echo -e "  ${DIM}bash install${NC}"
    echo -e "  ${DIM}bash install a${NC}"
    echo -e "  ${DIM}bash install server-b${NC}"
    echo
    echo -e "${WHITE}${BOLD}Manual installation:${NC}"
    echo -e "  ${DIM}bash install_a.sh${NC}    # For Server A only"
    echo -e "  ${DIM}bash install_b.sh${NC}    # For Server B only"
}

# Main function
main() {
    # Check for help first
    if [ $# -gt 0 ] && [[ "$1" =~ ^(--help|-h|help)$ ]]; then
        show_usage
        exit 0
    fi
    
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        print_error "Please run as root"
        exit 1
    fi
    
    print_header
    
    # Determine server type
    SERVER_TYPE=""
    if [ $# -eq 0 ]; then
        # No arguments, show menu
        show_server_menu
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Enter your choice${NC} ${DIM}[1-3]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter choice: "
        read choice
        
        case "$choice" in
            1)
                SERVER_TYPE="a"
                ;;
            2)
                SERVER_TYPE="b"
                ;;
            3)
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Invalid choice"
                exit 1
                ;;
        esac
    else
        case "$1" in
            "a"|"server-a"|"tunnel")
                SERVER_TYPE="a"
                ;;
            "b"|"server-b"|"dest"|"destination")
                SERVER_TYPE="b"
                ;;
            "auto")
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Unknown server type: $1"
                show_usage
                exit 1
                ;;
        esac
    fi
    
    print_info "Selected server type: Server $SERVER_TYPE"
    echo
    
    if [ "$SERVER_TYPE" = "a" ]; then
        install_server_a
    elif [ "$SERVER_TYPE" = "b" ]; then
        install_server_b
    else
        print_error "Could not determine server type"
        exit 1
    fi
}

# Run main function
main "$@"
