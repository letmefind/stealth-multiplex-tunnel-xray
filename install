#!/bin/bash

# VLESS+REALITY Tunnel Installation Script
# Modern Interactive Installation with Beautiful UI

set -e

# Debug mode - uncomment to enable debug output
# set -x

# Modern Color Palette
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;37m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# UI Elements
BOX_TOP="â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
BOX_BOTTOM="â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
BOX_SIDE="â”‚"
ARROW="â–¶"
CHECK="âœ“"
CROSS="âœ—"
STAR="âœ¦"
DOT="â€¢"

# Function to print with modern styling
print_header() {
    echo -e "${CYAN}${BOLD}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    ðŸš€ VLESS+REALITY TUNNEL ðŸš€                â•‘"
    echo "â•‘                   Modern Installation Script                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

print_section() {
    local title="$1"
    echo -e "\n${PURPLE}${BOLD}${STAR} ${title}${NC}"
    echo -e "${PURPLE}${BOX_TOP}${NC}"
}

print_section_end() {
    echo -e "${PURPLE}${BOX_BOTTOM}${NC}"
}

print_info() {
    echo -e "${BLUE}${ARROW}${NC} ${1}"
}

print_success() {
    echo -e "${GREEN}${CHECK}${NC} ${1}"
}

print_warning() {
    echo -e "${YELLOW}${DOT}${NC} ${1}"
}

print_error() {
    echo -e "${RED}${CROSS}${NC} ${1}"
}

print_input() {
    echo -e "${CYAN}${ARROW}${NC} ${1}"
}

print_config_item() {
    local key="$1"
    local value="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC} ${CYAN}${value}${NC}"
}

print_short_ids() {
    local key="$1"
    local short_ids="$2"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}${key}:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}${short_ids}${NC}"
}

# Function to show animated loading
show_loading() {
    local message="$1"
    local pid=$!
    local delay=0.1
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    
    echo -ne "${BLUE}${ARROW}${NC} ${message} "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Function to get user input with modern styling
get_input() {
    local prompt="$1"
    local default="$2"
    local value
    
    if [ -n "$default" ]; then
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC} ${DIM}[${default}]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "${value:-$default}"
    else
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}${prompt}${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter value: "
        read value
        echo "$value"
    fi
}

# Function to show confirmation dialog
confirm() {
    local message="$1"
    local default="${2:-n}"
    
    if [ "$default" = "y" ]; then
        echo -e "\n${GREEN}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[Y/n]${NC}"
        echo -ne "${GREEN}${ARROW}${NC} Enter choice: "
    else
        echo -e "\n${YELLOW}${ARROW}${NC} ${WHITE}${message}${NC} ${DIM}[y/N]${NC}"
        echo -ne "${YELLOW}${ARROW}${NC} Enter choice: "
    fi
    
    read -r response
    if [ "$default" = "y" ]; then
        [[ "$response" =~ ^[Nn]$ ]] && return 1 || return 0
    else
        [[ "$response" =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

# Function to generate UUID
generate_uuid() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    elif command -v python3 >/dev/null 2>&1; then
        python3 -c "import uuid; print(uuid.uuid4())"
    else
        cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "12345678-1234-1234-1234-123456789abc"
    fi
}

# Handle Nginx configuration conflicts
handle_nginx_conflicts() {
    print_info "Checking for Nginx configuration conflicts..."
    
    # Create backup directory
    BACKUP_DIR="/etc/nginx/backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$BACKUP_DIR"
    
    # Check if there are any existing default server configurations
    if [ -f /etc/nginx/sites-enabled/default ]; then
        print_warning "Found existing default Nginx site"
        print_info "Creating backup in: $BACKUP_DIR"
        cp /etc/nginx/sites-enabled/default "$BACKUP_DIR/"
        
        if confirm "Do you want to disable the existing default site to avoid conflicts?"; then
            rm -f /etc/nginx/sites-enabled/default
            print_success "Default Nginx site disabled (backup created)"
        else
            print_warning "Keeping existing default site - this may cause conflicts"
        fi
    fi
    
    # Check for other conflicting configurations
    CONFLICTING_CONFIGS=$(find /etc/nginx -name "*.conf" -exec grep -l "default_server" {} \; 2>/dev/null || true)
    if [ -n "$CONFLICTING_CONFIGS" ]; then
        print_warning "Found configurations with default_server directive:"
        echo "$CONFLICTING_CONFIGS" | while read config; do
            print_info "  - $config"
            cp "$config" "$BACKUP_DIR/" 2>/dev/null || true
        done
        print_info "Backups created in: $BACKUP_DIR"
        print_info "Our configuration will override these"
    fi
}

# Restore Nginx configuration from backup
restore_nginx_backup() {
    print_info "Available Nginx backups:"
    BACKUP_DIRS=$(find /etc/nginx -name "backup-*" -type d 2>/dev/null | sort -r)
    if [ -z "$BACKUP_DIRS" ]; then
        print_warning "No Nginx backups found"
        return 1
    fi
    
    echo "$BACKUP_DIRS" | nl
    echo
    echo -e "${CYAN}${ARROW}${NC} Enter backup number to restore ${DIM}[1]${NC}: \c"
    read BACKUP_CHOICE
    BACKUP_CHOICE="${BACKUP_CHOICE:-1}"
    
    BACKUP_DIR=$(echo "$BACKUP_DIRS" | sed -n "${BACKUP_CHOICE}p")
    if [ -z "$BACKUP_DIR" ]; then
        print_error "Invalid backup selection"
        return 1
    fi
    
    print_info "Restoring from: $BACKUP_DIR"
    if [ -d "$BACKUP_DIR" ]; then
        cp "$BACKUP_DIR"/* /etc/nginx/sites-enabled/ 2>/dev/null || true
        print_success "Nginx configuration restored from backup"
        return 0
    else
        print_error "Backup directory not found"
        return 1
    fi
}

# Check Xray version
check_xray_version() {
    if command -v xray >/dev/null 2>&1; then
        CURRENT_VERSION=$(xray version | head -1)
        print_info "Current Xray version: ${CYAN}${CURRENT_VERSION}${NC}"
        
        # Check for latest version
        if curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest >/dev/null 2>&1; then
            LATEST_VERSION=$(curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
            if [ -n "$LATEST_VERSION" ]; then
                print_info "Latest Xray version: ${CYAN}${LATEST_VERSION}${NC}"
                if echo "$CURRENT_VERSION" | grep -q "$LATEST_VERSION"; then
                    print_success "âœ… You have the latest version"
                else
                    print_warning "âš ï¸  Update available: ${LATEST_VERSION}"
                fi
            fi
        fi
    fi
}

# Install Xray offline
install_xray_offline() {
    print_info "Checking Xray installation options..."
    
    # Get latest version information
    LATEST_VERSION=""
    if curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest >/dev/null 2>&1; then
        LATEST_VERSION=$(curl -s --connect-timeout 5 https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
        if [ -n "$LATEST_VERSION" ]; then
            print_info "Latest Xray version available: ${CYAN}${LATEST_VERSION}${NC}"
        fi
    fi
    
    # Check if we have internet connectivity
    if curl -s --connect-timeout 5 https://github.com >/dev/null 2>&1; then
        print_info "Internet connection available"
        print_info "Installation methods:"
        print_info "  ${GREEN}1. Online Installation${NC} - Uses official Xray installer (recommended)"
        print_info "  ${YELLOW}2. Offline Installation${NC} - Downloads binary directly (for restricted networks)"
        
        if confirm "Do you want to try online installation first?"; then
            print_info "Attempting online installation..."
            if bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install; then
                print_success "Xray installed successfully via online method"
                if [ -n "$LATEST_VERSION" ]; then
                    print_info "Installed version: ${CYAN}$(xray version | head -1)${NC}"
                fi
                return 0
            else
                print_warning "Online installation failed, trying offline method..."
            fi
        else
            print_info "Skipping online installation, using offline method..."
        fi
    else
        print_warning "No internet connection detected, using offline method..."
    fi
    
    # Offline installation method
    print_info "Installing Xray offline..."
    
    # Detect system architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="64" ;;
        aarch64|arm64) ARCH="arm64-v8a" ;;
        armv7l) ARCH="arm32-v7a" ;;
        *) print_error "Unsupported architecture: $ARCH"; return 1 ;;
    esac
    print_info "Detected architecture: ${CYAN}${ARCH}${NC}"
    
    # Use latest version if available, otherwise fallback to stable
    if [ -n "$LATEST_VERSION" ]; then
        XRAY_VERSION="$LATEST_VERSION"
        print_info "Using latest version: ${CYAN}${XRAY_VERSION}${NC}"
    else
        XRAY_VERSION="v1.8.18"
        print_warning "Using fallback version: ${CYAN}${XRAY_VERSION}${NC}"
    fi
    
    # Create temporary directory
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # Download Xray binary (try multiple mirrors)
    DOWNLOAD_URLS=(
        "https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://mirror.ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
        "https://download.fastgit.org/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${ARCH}.zip"
    )
    
    for url in "${DOWNLOAD_URLS[@]}"; do
        print_info "Trying to download from: $url"
        if wget -q --timeout=10 "$url" -O xray.zip || curl -L --connect-timeout 10 "$url" -o xray.zip; then
            print_success "Downloaded Xray binary successfully"
            break
        else
            print_warning "Failed to download from: $url"
        fi
    done
    
    if [ ! -f "xray.zip" ]; then
        print_error "Failed to download Xray binary from all mirrors"
        print_info "Please download Xray manually:"
        print_info "1. Go to: https://github.com/XTLS/Xray-core/releases"
        print_info "2. Download Xray-linux-${ARCH}.zip"
        print_info "3. Extract and place xray binary in /usr/local/bin/"
        print_info "4. Run: chmod +x /usr/local/bin/xray"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Extract and install
    if command -v unzip >/dev/null 2>&1; then
        unzip -q xray.zip
    else
        print_error "unzip command not found. Please install unzip first."
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Install binary
    if [ -f "xray" ]; then
        cp xray /usr/local/bin/
        chmod +x /usr/local/bin/xray
        
        # Create systemd service
        cat > /etc/systemd/system/xray.service << 'EOF'
[Unit]
Description=Xray Service
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/config.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
        
        # Create directories
        mkdir -p /etc/xray /var/log/xray
        chown nobody:nogroup /var/log/xray
        
        # Enable service
        systemctl daemon-reload
        systemctl enable xray
        
        print_success "Xray installed successfully via offline method"
        INSTALLED_VERSION=$(/usr/local/bin/xray version | head -1)
        print_info "Installed version: ${CYAN}${INSTALLED_VERSION}${NC}"
        if [ -n "$LATEST_VERSION" ] && [ "$XRAY_VERSION" = "$LATEST_VERSION" ]; then
            print_success "âœ… Latest version installed successfully"
        fi
        
        cd /
        rm -rf "$TEMP_DIR"
        return 0
    else
        print_error "Xray binary not found in downloaded archive"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
}

# Function to generate Reality keys
generate_reality_keys() {
    if command -v xray >/dev/null 2>&1; then
        KEYS=$(xray x25519 2>/dev/null)
        PUBLIC_KEY=$(echo "$KEYS" | grep "Public key:" | cut -d' ' -f3)
        PRIVATE_KEY=$(echo "$KEYS" | grep "Private key:" | cut -d' ' -f3)
        
        # Generate 20 different short IDs
        SHORT_IDS=""
        for i in {1..20}; do
            SHORT_ID=$(openssl rand -hex 8 2>/dev/null)
            if [ $i -eq 1 ]; then
                SHORT_IDS="\"$SHORT_ID\""
            else
                SHORT_IDS="$SHORT_IDS, \"$SHORT_ID\""
            fi
        done
        
        # Debug: Show generated short IDs
        echo "Generated short IDs: $SHORT_IDS" >&2
        
        # Debug: Check if keys were parsed correctly
        if [ -z "$PUBLIC_KEY" ] || [ -z "$PRIVATE_KEY" ]; then
            print_warning "Failed to parse Reality keys, using default keys"
            PUBLIC_KEY="wwgbwD3pK6aBzxtMzAyAdzV8430zraDqrCrH7tivDV4"
            PRIVATE_KEY="kEHlrW7KE0TxG_UhhOwE2YzMbzGlWign5rSrcweFVkY"
            SHORT_IDS="\"db78ea236c7e33f5\", \"a1b2c3d4e5f67890\", \"1234567890abcdef\", \"fedcba0987654321\", \"1111222233334444\", \"5555666677778888\", \"9999aaaabbbbcccc\", \"ddddeeeeffff0000\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\", \"02468ace13579bdf\", \"fdb97531eca86420\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\""
        else
            print_success "Generated Reality keys successfully"
        fi
        
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short IDs (20):${NC} ${CYAN}Generated 20 different short IDs${NC}"
    else
        print_warning "Xray not found, using default keys"
        PUBLIC_KEY="wwgbwD3pK6aBzxtMzAyAdzV8430zraDqrCrH7tivDV4"
        PRIVATE_KEY="kEHlrW7KE0TxG_UhhOwE2YzMbzGlWign5rSrcweFVkY"
        SHORT_IDS="\"db78ea236c7e33f5\", \"a1b2c3d4e5f67890\", \"1234567890abcdef\", \"fedcba0987654321\", \"1111222233334444\", \"5555666677778888\", \"9999aaaabbbbcccc\", \"ddddeeeeffff0000\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\", \"02468ace13579bdf\", \"fdb97531eca86420\", \"0123456789abcdef\", \"fedcba9876543210\", \"abcdef0123456789\", \"9876543210fedcba\", \"13579bdf2468ace0\""
        
        print_success "Using default Reality keys"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Public Key:${NC} ${CYAN}${PUBLIC_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key:${NC} ${CYAN}${PRIVATE_KEY}${NC}"
        echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short IDs (20):${NC} ${CYAN}Using 20 default short IDs${NC}"
    fi
    
    # Export the variables so they're available globally
    export PUBLIC_KEY
    export PRIVATE_KEY
    export SHORT_IDS
}

# Function to validate port
validate_port() {
    local port="$1"
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        return 1
    fi
    return 0
}

# Function to validate IP
validate_ip() {
    local ip="$1"
    # More comprehensive IP validation
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Check each octet is between 0-255
        IFS='.' read -ra ADDR <<< "$ip"
        for i in "${ADDR[@]}"; do
            if [[ $i -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# Function to show server selection menu
show_server_menu() {
    print_section "Server Type Selection"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Choose your server type:${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}1.${NC} ${WHITE}Server A (Tunnel Server)${NC} ${DIM}- Receives traffic and forwards to Server B${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}2.${NC} ${WHITE}Server B (Destination Server)${NC} ${DIM}- Receives tunneled traffic and routes to services${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${CYAN}3.${NC} ${WHITE}Auto-detect${NC} ${DIM}- Automatically detect server type${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC}"
    print_section_end
}

# Function to detect server type
detect_server_type() {
    print_info "Auto-detecting server type..." >&2
    
    if command -v nginx >/dev/null 2>&1; then
        echo "b"
    else
        echo "a"
    fi
}

# Function to install Server A
install_server_a() {
    print_section "Server A Configuration"
    
    # Get configuration from user
    print_info "I will ask you for each configuration detail one by one."
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: Server B IP
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the IP address of Server B (destination server)?"
    echo -e "${DIM}This is the server where your tunneled traffic will be sent.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
    read SERVER_B_IP
    
    while [ -z "$SERVER_B_IP" ] || ! validate_ip "$SERVER_B_IP"; do
        if [ -z "$SERVER_B_IP" ]; then
            print_error "Server B IP address is required. Please enter a valid IP address."
        else
            print_error "Invalid IP address format. Please enter a valid IP like 192.168.1.100"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter Server B IP address: \c"
        read SERVER_B_IP
    done
    print_success "Server B IP: ${CYAN}${SERVER_B_IP}${NC}"
    
    # Question 2: Tunnel Port
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What port should be used for the VLESS tunnel connection?"
    echo -e "${DIM}This is the port that Server A will connect to on Server B.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        print_error "Invalid port number. Please enter a port between 1-65535"
        echo -e "${CYAN}${ARROW}${NC} Enter tunnel port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Question 3: Reality Server Name
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} What server name should be used for Reality protocol (SNI)?"
    echo -e "${DIM}This is used to disguise the connection as legitimate traffic.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Reality server name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
    read SERVER_NAME
    SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
    print_success "Reality Server Name: ${CYAN}${SERVER_NAME}${NC}"
    
    # Generate keys
    generate_reality_keys
    
    # Generate UUID
    UUID=$(generate_uuid)
    print_success "Generated UUID: ${CYAN}${UUID}${NC}"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "Server B IP" "$SERVER_B_IP"
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Server Name" "$SERVER_NAME"
    print_config_item "UUID" "$UUID"
    
    print_config_item "Public Key (for Server A)" "$PUBLIC_KEY"
    print_config_item "Private Key (for Server B)" "$PRIVATE_KEY"
    print_short_ids "Short IDs (20 different)" "$SHORT_IDS"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server A installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray
    print_section "Installing Xray"
    if ! command -v xray >/dev/null 2>&1; then
        install_xray_offline
    else
        print_success "Xray is already installed"
        check_xray_version
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Generate Server A configuration
    cat > /etc/xray/a.json << EOF
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "tag": "entry-80",
      "listen": "0.0.0.0",
      "port": 80,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 80, "network": "tcp" }
    },
    {
      "tag": "entry-443",
      "listen": "0.0.0.0",
      "port": 443,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 443, "network": "tcp" }
    },
    {
      "tag": "entry-8080",
      "listen": "0.0.0.0",
      "port": 8080,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 8080, "network": "tcp" }
    },
    {
      "tag": "entry-8443",
      "listen": "0.0.0.0",
      "port": 8443,
      "protocol": "dokodemo-door",
      "settings": { "address": "127.0.0.1", "port": 8443, "network": "tcp" }
    }
  ],
  "outbounds": [
    {
      "tag": "to-b",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "$SERVER_B_IP",
            "port": $TUNNEL_PORT,
            "users": [
              { "id": "$UUID", "encryption": "none" }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "serverName": "$SERVER_NAME",
          "publicKey": "$PUBLIC_KEY",
          "shortId": "$(echo "$SHORT_IDS" | cut -d',' -f1 | tr -d '"' | tr -d ' ')",
          "fingerprint": "chrome",
          "spiderX": "/"
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 1000000,
          "scMaxConcurrentPosts": 6,
          "scMinPostsIntervalMs": 25,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 200,
          "keepaliveperiod": 60,
          "mode": "auto"
        }
      }
    },
    { "protocol": "freedom", "tag": "direct" }
  ],
  "routing": {
    "domainStrategy": "AsIs",
    "rules": [
      { "type": "field", "inboundTag": ["entry-80"],   "outboundTag": "to-b" },
      { "type": "field", "inboundTag": ["entry-443"],  "outboundTag": "to-b" },
      { "type": "field", "inboundTag": ["entry-8080"], "outboundTag": "to-b" },
      { "type": "field", "inboundTag": ["entry-8443"], "outboundTag": "to-b" }
    ]
  }
}
EOF
    
    # Set permissions
    chown root:root /etc/xray/a.json
    chmod 644 /etc/xray/a.json
    print_success "Configuration file created: /etc/xray/a.json"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Service"
    cat > /etc/systemd/system/xray-a.service << 'EOF'
[Unit]
Description=Xray Service (Server A)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/a.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Reload systemd and start service
    systemctl daemon-reload
    systemctl enable xray-a
    systemctl restart xray-a
    print_success "Service created and started: xray-a.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server A installation completed successfully!"
    echo
    print_info "Configuration saved to: /etc/xray/a.json"
    print_info "Service: xray-a.service"
    print_info "Logs location: /var/log/xray/"
    echo
    print_warning "IMPORTANT: Save these details for Server B installation:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}UUID:${NC} ${CYAN}${UUID}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Private Key (for Server B):${NC} ${CYAN}${PRIVATE_KEY}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Short IDs (20 different):${NC} ${CYAN}${SHORT_IDS}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Server Name:${NC} ${CYAN}${SERVER_NAME}${NC}"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Tunnel Port:${NC} ${CYAN}${TUNNEL_PORT}${NC}"
    echo
    print_info "Note: Public Key is already configured in Server A, Private Key goes to Server B"
    print_section_end
}

# Function to install Server B
install_server_b() {
    print_section "Server B Configuration"
    
    print_info "I will ask you for each configuration detail one by one."
    echo
    print_warning "You need the details from Server A installation first!"
    echo
    
    # Ensure we can read input
    if ! [ -t 0 ]; then
        print_error "Input not available. Please run interactively."
        exit 1
    fi
    
    # Question 1: UUID from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 1:${NC} What is the UUID from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter UUID: \c"
    read UUID
    if [ -z "$UUID" ]; then
        print_error "UUID is required. Please enter the UUID from Server A."
        exit 1
    fi
    print_success "UUID: ${CYAN}${UUID}${NC}"
    
    # Question 2: Private Key from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 2:${NC} What is the Private Key from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Private Key: \c"
    read SERVER_B_PRIVATE_KEY
    if [ -z "$SERVER_B_PRIVATE_KEY" ]; then
        print_error "Private Key is required. Please enter the Private Key from Server A."
        exit 1
    fi
    print_success "Private Key: ${CYAN}${SERVER_B_PRIVATE_KEY}${NC}"
    
    # Question 3: Short IDs from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 3:${NC} What are the Short IDs from Server A installation?"
    echo -e "${DIM}This was generated and shown to you during Server A setup (20 different short IDs).${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Short IDs (comma-separated): \c"
    read SERVER_B_SHORT_IDS
    if [ -z "$SERVER_B_SHORT_IDS" ]; then
        print_error "Short IDs are required. Please enter the Short IDs from Server A."
        exit 1
    fi
    print_success "Short IDs: ${CYAN}${SERVER_B_SHORT_IDS}${NC}"
    
    # Question 4: Server Name from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 4:${NC} What is the Server Name from Server A installation?"
    echo -e "${DIM}This is the Reality server name (SNI) you used on Server A.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Server Name ${DIM}[www.accounts.accesscontrol.windows.net]${NC}: \c"
    read SERVER_NAME
    SERVER_NAME="${SERVER_NAME:-www.accounts.accesscontrol.windows.net}"
    print_success "Server Name: ${CYAN}${SERVER_NAME}${NC}"
    
    # Question 5: Tunnel Port from Server A
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 5:${NC} What is the Tunnel Port from Server A installation?"
    echo -e "${DIM}This is the port you used for VLESS connection on Server A.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
    read TUNNEL_PORT
    TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    
    while ! validate_port "$TUNNEL_PORT"; do
        print_error "Invalid port number. Please enter a port between 1-65535"
        echo -e "${CYAN}${ARROW}${NC} Enter Tunnel Port ${DIM}[8081]${NC}: \c"
        read TUNNEL_PORT
        TUNNEL_PORT="${TUNNEL_PORT:-8081}"
    done
    print_success "Tunnel Port: ${CYAN}${TUNNEL_PORT}${NC}"
    
    # Question 6: Target Port
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 6:${NC} What port do you want to tunnel to your local service?"
    echo -e "${DIM}This is the port of your local service (e.g., 8443 for XMPlus).${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter target port ${DIM}[8443]${NC}: \c"
    read TARGET_PORT
    TARGET_PORT="${TARGET_PORT:-8443}"
    
    while ! validate_port "$TARGET_PORT" || [ "$TARGET_PORT" = "80" ] || [ "$TARGET_PORT" = "443" ]; do
        if [ "$TARGET_PORT" = "80" ] || [ "$TARGET_PORT" = "443" ]; then
            print_error "Target port cannot be 80 or 443 (use nginx for these)"
        else
            print_error "Invalid port number. Please enter a port between 1-65535"
        fi
        echo -e "${CYAN}${ARROW}${NC} Enter target port ${DIM}[8443]${NC}: \c"
        read TARGET_PORT
        TARGET_PORT="${TARGET_PORT:-8443}"
    done
    print_success "Target Port: ${CYAN}${TARGET_PORT}${NC}"
    
    # Question 7: Domain for nginx
    echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Question 7:${NC} What domain name should be used for the nginx decoy site?"
    echo -e "${DIM}This is used for the fake website that hides the tunnel.${NC}"
    echo -e "${CYAN}${ARROW}${NC} Enter domain name ${DIM}[test.bale.cyou]${NC}: \c"
    read DOMAIN
    DOMAIN="${DOMAIN:-test.bale.cyou}"
    print_success "Domain: ${CYAN}${DOMAIN}${NC}"
    
    print_section_end
    
    # Show configuration summary
    print_section "Configuration Summary"
    print_config_item "UUID" "$UUID"
    print_config_item "Private Key" "$SERVER_B_PRIVATE_KEY"
    print_short_ids "Short IDs (20 different)" "$SERVER_B_SHORT_IDS"
    print_config_item "Server Name" "$SERVER_NAME"
    print_config_item "Tunnel Port" "$TUNNEL_PORT"
    print_config_item "Target Port" "$TARGET_PORT"
    print_config_item "Domain" "$DOMAIN"
    print_section_end
    
    # Confirm installation
    if ! confirm "Do you want to proceed with Server B installation?"; then
        print_warning "Installation cancelled"
        exit 0
    fi
    
    # Install Xray and Nginx
    print_section "Installing Services"
    if ! command -v xray >/dev/null 2>&1; then
        install_xray_offline
    else
        print_success "Xray is already installed"
        check_xray_version
    fi
    
    if ! command -v nginx >/dev/null 2>&1; then
        print_info "Installing Nginx..."
        if command -v apt >/dev/null 2>&1; then
            apt update && apt install -y nginx
        elif command -v yum >/dev/null 2>&1; then
            yum install -y nginx
        elif command -v dnf >/dev/null 2>&1; then
            dnf install -y nginx
        fi
        print_success "Nginx installed successfully"
    else
        print_success "Nginx is already installed"
    fi
    print_section_end
    
    # Create directories and configuration
    print_section "Creating Configuration"
    mkdir -p /etc/xray /var/log/xray
    
    # Generate Server B configuration
    cat > /etc/xray/b.json << EOF
{
  "log": {
    "access": "/var/log/xray/access.log",
    "error": "/var/log/xray/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "tag": "tunnel-in",
      "listen": "0.0.0.0",
      "port": $TUNNEL_PORT,
      "protocol": "vless",
      "settings": {
        "clients": [
          { "id": "$UUID" }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "splithttp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "www.microsoft.com:443",
          "serverNames": ["$SERVER_NAME"],
          "privateKey": "$SERVER_B_PRIVATE_KEY",
          "shortIds": [$SERVER_B_SHORT_IDS]
        },
        "splithttpSettings": {
          "path": "/assets",
          "scMaxEachPostBytes": 1000000,
          "scMaxConcurrentPosts": 6,
          "scMinPostsIntervalMs": 25,
          "noSSEHeader": false,
          "noGRPCHeader": true,
          "xPaddingBytes": 200,
          "keepaliveperiod": 60,
          "mode": "auto"
        }
      }
    }
  ],
  "outbounds": [
    { "tag": "to-nginx-80",  "protocol": "freedom", "settings": { "redirect": "127.0.0.1:80"  } },
    { "tag": "to-nginx-443", "protocol": "freedom", "settings": { "redirect": "127.0.0.1:443" } },
    { "tag": "to-xmplus",    "protocol": "freedom", "settings": { "redirect": "127.0.0.1:$TARGET_PORT" } }
  ],
  "routing": {
    "rules": [
      { "type": "field", "inboundTag": ["tunnel-in"], "port": "80",   "outboundTag": "to-nginx-80"  },
      { "type": "field", "inboundTag": ["tunnel-in"], "port": "443",  "outboundTag": "to-nginx-443" },
      { "type": "field", "inboundTag": ["tunnel-in"], "port": "8080,$TARGET_PORT,8082,9090", "outboundTag": "to-xmplus" }
    ]
  }
}
EOF
    
    # Set permissions
    chown root:root /etc/xray/b.json
    chmod 644 /etc/xray/b.json
    print_success "Configuration file created: /etc/xray/b.json"
    print_section_end
    
    # Generate Nginx configuration
    print_section "Setting Up Nginx"
    
    # Handle Nginx configuration conflicts
    handle_nginx_conflicts
    
    # Disable default Nginx site to avoid conflicts
    print_info "Disabling default Nginx site to avoid port conflicts..."
    if [ -f /etc/nginx/sites-enabled/default ]; then
        rm -f /etc/nginx/sites-enabled/default
        print_success "Default Nginx site disabled"
    fi
    
    # Also disable default site in sites-available
    if [ -f /etc/nginx/sites-available/default ]; then
        rm -f /etc/nginx/sites-available/default
        print_success "Default Nginx site removed from sites-available"
    fi
    
    cat > /etc/nginx/conf.d/stealth-$TUNNEL_PORT.conf << EOF
# Public HTTP -> redirect to HTTPS
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    return 301 https://\$host\$request_uri;
}

# Public HTTPS decoy site
server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;
    server_name $DOMAIN;

    ssl_certificate     /etc/ssl/certs/decoy.crt;
    ssl_certificate_key /etc/ssl/private/decoy.key;

    # Minimal "normal" site
    root /var/www/html;
    index index.html;

    # Security headers (optional but fine)
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Serve files; no tunnel proxy here
    location / {
        try_files \$uri \$uri/ =404;
    }

    # Block dotfiles & configs
    location ~ /\\.         { deny all; }
    location ~ \\.(log|conf)\$ { deny all; }
}
EOF
    
    # Create decoy SSL certificates if they don't exist
    if [ ! -f "/etc/ssl/certs/decoy.crt" ]; then
        print_info "Creating decoy SSL certificates..."
        mkdir -p /etc/ssl/certs /etc/ssl/private
        
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/ssl/private/decoy.key \
            -out /etc/ssl/certs/decoy.crt \
            -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"
        print_success "SSL certificates created"
    fi
    
    # Create web root and index
    mkdir -p /var/www/html
    cat > /var/www/html/index.html << 'HTML'
<!DOCTYPE html>
<html>
<head>
    <title>Welcome</title>
</head>
<body>
    <h1>Welcome to our website</h1>
    <p>This is a normal website.</p>
</body>
</html>
HTML
    print_success "Nginx configuration created: /etc/nginx/conf.d/stealth-$TUNNEL_PORT.conf"
    print_section_end
    
    # Create systemd service
    print_section "Setting Up Services"
    cat > /etc/systemd/system/xray-b.service << 'EOF'
[Unit]
Description=Xray Service (Server B)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=nobody
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /etc/xray/b.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    # Test Nginx configuration before restarting
    print_info "Testing Nginx configuration..."
    if nginx -t; then
        print_success "Nginx configuration test passed"
    else
        print_error "Nginx configuration test failed"
        print_info "Please check the configuration manually"
        exit 1
    fi
    
    # Reload systemd and start services
    systemctl daemon-reload
    systemctl enable xray-b
    systemctl restart xray-b
    systemctl enable nginx
    systemctl restart nginx
    print_success "Services created and started: xray-b.service, nginx.service"
    print_section_end
    
    # Show completion message
    print_section "Installation Complete"
    print_success "Server B installation completed successfully!"
    echo
    print_info "Configuration files:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Xray config:${NC} /etc/xray/b.json"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Nginx config:${NC} /etc/nginx/conf.d/stealth-$TUNNEL_PORT.conf"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Logs location:${NC} /var/log/xray/"
    echo
    print_success "Tunnel is now active!"
    print_info "Traffic routing:"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Ports 80,443:${NC} â†’ nginx"
    echo -e "${GRAY}${BOX_SIDE}${NC} ${WHITE}Ports 8080,$TARGET_PORT,8082,9090:${NC} â†’ target service"
    print_section_end
}

# Function to show usage
show_usage() {
    print_header
    echo -e "${WHITE}${BOLD}Usage:${NC} bash install [server-type]"
    echo
    echo -e "${WHITE}${BOLD}Server types:${NC}"
    echo -e "  ${CYAN}a, server-a, tunnel${NC}    Install on Server A (Tunnel Server)"
    echo -e "  ${CYAN}b, server-b, dest${NC}     Install on Server B (Destination Server)"
    echo -e "  ${CYAN}auto${NC}                  Auto-detect server type (default)"
    echo
    echo -e "${WHITE}${BOLD}Examples:${NC}"
    echo -e "  ${DIM}bash install${NC}"
    echo -e "  ${DIM}bash install a${NC}"
    echo -e "  ${DIM}bash install server-b${NC}"
    echo
    echo -e "${WHITE}${BOLD}Manual installation:${NC}"
    echo -e "  ${DIM}bash install_a.sh${NC}    # For Server A only"
    echo -e "  ${DIM}bash install_b.sh${NC}    # For Server B only"
}

# Main function
main() {
    # Check for help first
    if [ $# -gt 0 ] && [[ "$1" =~ ^(--help|-h|help)$ ]]; then
        show_usage
        exit 0
    fi
    
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        print_error "Please run as root"
        exit 1
    fi
    
    print_header
    
    # Determine server type
    SERVER_TYPE=""
    if [ $# -eq 0 ]; then
        # No arguments, show menu
        show_server_menu
        echo -e "\n${CYAN}${ARROW}${NC} ${WHITE}Enter your choice${NC} ${DIM}[1-3]${NC}"
        echo -ne "${CYAN}${ARROW}${NC} Enter choice: "
        read choice
        
        case "$choice" in
            1)
                SERVER_TYPE="a"
                ;;
            2)
                SERVER_TYPE="b"
                ;;
            3)
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Invalid choice"
                exit 1
                ;;
        esac
    else
        case "$1" in
            "a"|"server-a"|"tunnel")
                SERVER_TYPE="a"
                ;;
            "b"|"server-b"|"dest"|"destination")
                SERVER_TYPE="b"
                ;;
            "auto")
                SERVER_TYPE=$(detect_server_type)
                ;;
            *)
                print_error "Unknown server type: $1"
                show_usage
                exit 1
                ;;
        esac
    fi
    
    print_info "Selected server type: Server $SERVER_TYPE"
    echo
    
    if [ "$SERVER_TYPE" = "a" ]; then
        install_server_a
    elif [ "$SERVER_TYPE" = "b" ]; then
        install_server_b
    else
        print_error "Could not determine server type"
        exit 1
    fi
}

# Run main function
main "$@"
